
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>s2.builder.graph</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">s2.builder.graph</h1>
        <section id="module_content">
<section class="section ddoc_module_members_section">
  <div class="ddoc_module_members">
    <ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph" id="Graph"><code class="code">Graph</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph"></span>class <code class="code">Graph</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    An S2Builder::<code class="code">Graph</code> represents a collection of snapped edges that is passed
 to a Layer for assembly.  (Example layers include polygons, polylines, and
 polygon meshes.)  The <code class="code">Graph</code> object does not own any of its underlying data;
 it is simply a view of data that is stored elsewhere.  You will only
 need this interface if you want to implement a new Layer subtype.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    The graph consists of vertices and directed edges.  Vertices are numbered
 sequentially starting from zero.  An edge is represented as a pair of
 vertex ids.  The edges are sorted in lexicographic order, therefore all of
 the outgoing edges from a particular vertex form a contiguous range.
<br><br>
 S2Builder::<code class="code">Graph</code> is movable and copyable.  Note that although this class
 does not own the underlying vertex and edge data, S2Builder guarantees that
 all <code class="code">Graph</code> objects passed to S2Builder::Layer::Build() methods will remain
 valid until all layers have been built.
<br><br>
 TODO(ericv): Consider pulling out the methods that are helper functions for
 Layer implementations (such as GetDirectedLoops) into s2builderutil_graph.h.
  </p>
</div>

</section>
<ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.this" id="Graph.this"><code class="code">this</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.this"></span>this();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    The default constructor exists only for the benefit of STL containers.
The graph must be initialized (using the assignment operator) before it
is used.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.this" id="Graph.this"><code class="code">this</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.this.2"></span>this(in GraphOptions <code class="code">options</code>, in S2Point[] <code class="code">vertices</code>, in Edge[] <code class="code">edges</code>, in InputEdgeIdSetId[] <code class="code">input_edge_id_set_ids</code>, in IdSetLexicon <code class="code">input_edge_id_set_lexicon</code>, in LabelSetId[] <code class="code">label_set_ids</code>, in IdSetLexicon <code class="code">label_set_lexicon</code>, IsFullPolygonPredicate <code class="code">is_full_polygon_predicate</code> = IsFullPolygonPredicate());

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Note that most of the parameters are passed by const reference and must
 exist for the duration of the Graph object.  Notes on parameters:
 "<code class="code">options</code>":
    - the GraphOptions used to build the Graph.  In some cases these
      can be different than the <code class="code">options</code> provided by the Layer.
 "<code class="code">vertices</code>":
   - a vector of S2Points indexed by VertexId.
 "<code class="code">edges</code>":
   - a vector of VertexId pairs (sorted in lexicographic order)
     indexed by EdgeId.
 "<code class="code">input_edge_id_set_ids</code>":
   - a vector indexed by EdgeId that allows access to the set of
     InputEdgeIds that were mapped to the given edge, by looking up the
     returned value (an InputEdgeIdSetId) in "<code class="code">input_edge_id_set_lexicon</code>".
 "<code class="code">input_edge_id_set_lexicon</code>":
   - a class that maps an InputEdgeIdSetId to a set of InputEdgeIds.
 "<code class="code">label_set_ids</code>":
   - a vector indexed by InputEdgeId that allows access to the set of
     labels that were attached to the given input edge, by looking up the
     returned value (a LabelSetId) in the "<code class="code">label_set_lexicon</code>".
 "<code class="code">label_set_lexicon</code>":
   - a class that maps a LabelSetId to a set of S2Builder::Labels.
 "<code class="code">is_full_polygon_predicate</code>":
   - a predicate called to determine whether a graph consisting only of
     polygon degeneracies represents the empty polygon or the full polygon
     (see s2builder.h for details).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.numVertices" id="Graph.numVertices"><code class="code">numVertices</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.numVertices"></span>const VertexId <code class="code">numVertices</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the number of vertices in the graph.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.vertex" id="Graph.vertex"><code class="code">vertex</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.vertex"></span>const const(S2Point) <code class="code">vertex</code>(VertexId <code class="code">v</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the <code class="code">vertex</code> at the given index.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.vertices" id="Graph.vertices"><code class="code">vertices</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.vertices"></span>const const(S2Point[]) <code class="code">vertices</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the entire set of <code class="code">vertices</code>.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.numEdges" id="Graph.numEdges"><code class="code">numEdges</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.numEdges"></span>const EdgeId <code class="code">numEdges</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the total number of edges in the graph.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.edge" id="Graph.edge"><code class="code">edge</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.edge"></span>const Edge <code class="code">edge</code>(EdgeId <code class="code">e</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the endpoints of the given <code class="code">edge</code> (as vertex indices).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.edges" id="Graph.edges"><code class="code">edges</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.edges"></span>const const(Edge[]) <code class="code">edges</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the entire set of <code class="code">edges</code>.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.reverse" id="Graph.reverse"><code class="code">reverse</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.reverse"></span>static Edge <code class="code">reverse</code>(in Edge <code class="code">e</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Given an edge (src, dst), returns the <code class="code">reverse</code> edge (dst, src).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.getInEdgeIds" id="Graph.getInEdgeIds"><code class="code">getInEdgeIds</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.getInEdgeIds"></span>const EdgeId[] <code class="code">getInEdgeIds</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns a vector of edge ids sorted in lexicographic order by
 (destination, origin).  All of the incoming edges to each vertex form a
 contiguous subrange of this ordering.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.getSiblingMap" id="Graph.getSiblingMap"><code class="code">getSiblingMap</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.getSiblingMap"></span>const EdgeId[] <code class="code">getSiblingMap</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Given a graph such that every directed edge has a sibling, returns a map
 from EdgeId to the sibling EdgeId.  This method is identical to
 GetInEdgeIds() except that (1) it requires edges to have siblings, and
 (2) undirected degenerate edges are grouped together in pairs such that
 one edge is the sibling of the other.  Handles duplicate edges correctly
 and is also consistent with GetLeftTurnMap().

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">REQUIRES:</span>
An option is chosen that guarantees sibling pairs:
     (options.sibling_pairs() == { REQUIRE, CREATE } ||
      options.edge_type() == UNDIRECTED)
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.makeSiblingMap" id="Graph.makeSiblingMap"><code class="code">makeSiblingMap</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.makeSiblingMap"></span>const void <code class="code">makeSiblingMap</code>(ref EdgeId[] <code class="code">in_edge_ids</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Like GetSiblingMap(), but constructs the map starting from the vector of
 incoming edge ids returned by GetInEdgeIds().  (This operation is a no-op
 except unless undirected degenerate edges are present, in which case such
 edges are grouped together in pairs to satisfy the requirement that every
 edge must have a sibling edge.)
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.VertexOutMap" id="Graph.VertexOutMap"><code class="code">VertexOutMap</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.VertexOutMap"></span>class <code class="code">VertexOutMap</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    A helper class for <code class="code">VertexOutMap</code> that represents the outgoing edges
from a given vertex.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    A helper class for <code class="code">VertexOutMap</code> that represents the outgoing edge *ids*
from a given vertex.
<br><br>
 A class that maps vertices to their outgoing edge ids.  Example usage:
   <code class="code">VertexOutMap</code> out(g);
   for (Graph::EdgeId e : out.edge_ids(v)) { ... }
   for (const Graph::Edge&amp; edge : out.edges(v)) { ... }
  </p>
</div>

</section>
<ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.VertexOutMap.edges" id="Graph.VertexOutMap.edges"><code class="code">edges</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.VertexOutMap.edges"></span>const auto <code class="code">edges</code>(VertexId <code class="code">v0</code>, VertexId <code class="code">v1</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns a range of Edge (or edge ids) between a specific pair of vertices.
  </p>
</div>

</section>

</div>

</li>
</ul>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.MAX_INPUT_EDGE_ID" id="Graph.MAX_INPUT_EDGE_ID"><code class="code">MAX_INPUT_EDGE_ID</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.MAX_INPUT_EDGE_ID"></span>static immutable InputEdgeId <code class="code">MAX_INPUT_EDGE_ID</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Defines a value larger than any valid InputEdgeId.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.NO_INPUT_EDGE_ID" id="Graph.NO_INPUT_EDGE_ID"><code class="code">NO_INPUT_EDGE_ID</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.NO_INPUT_EDGE_ID"></span>static immutable InputEdgeId <code class="code">NO_INPUT_EDGE_ID</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    The following value of InputEdgeId means that an edge does not
corresponds to any input edge.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.inputEdgeIds" id="Graph.inputEdgeIds"><code class="code">inputEdgeIds</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.inputEdgeIds"></span>const const(IdSetLexicon.IdSet) <code class="code">inputEdgeIds</code>(EdgeId <code class="code">e</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the set of input edge ids that were snapped to the given
 edge.  ("Input edge ids" are assigned to input edges sequentially in
 the order they are added to the builder.)  For example, if input
 edges 2 and 17 were snapped to edge 12, then input_edge_ids(12)
 returns a set containing the numbers 2 and 17.  Example usage:

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    for (InputEdgeId input_edge_id : g.input_edge_ids(<code class="code">e</code>)) { ... }
<br><br>
 Please note the following:
<br><br>
  - When edge chains are simplified, the simplified edge is assigned all
    the input edge ids associated with edges of the chain.
<br><br>
  - Edges can also have multiple input edge ids due to edge merging
    (if DuplicateEdges::MERGE is specified).
<br><br>
  - Siblings edges automatically created by EdgeType::UNDIRECTED or
    SiblingPairs::CREATE have an empty set of input edge ids.  (However
    you can use a LabelFetcher to retrieve the set of labels associated
    with both edges of a given sibling pair.)
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.inputEdgeIdSetId" id="Graph.inputEdgeIdSetId"><code class="code">inputEdgeIdSetId</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.inputEdgeIdSetId"></span>const InputEdgeIdSetId <code class="code">inputEdgeIdSetId</code>(EdgeId <code class="code">e</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Low-level method that returns an integer representing the entire set of
 input edge ids that were snapped to the given edge.  The elements of the
 IdSet can be accessed using input_edge_id_set_lexicon().
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.inputEdgeIdSetIds" id="Graph.inputEdgeIdSetIds"><code class="code">inputEdgeIdSetIds</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.inputEdgeIdSetIds"></span>const const(InputEdgeIdSetId[]) <code class="code">inputEdgeIdSetIds</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Low-level method that returns a vector where each element represents the
set of input edge ids that were snapped to a particular output edge.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.inputEdgeIdSetLexicon" id="Graph.inputEdgeIdSetLexicon"><code class="code">inputEdgeIdSetLexicon</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.inputEdgeIdSetLexicon"></span>const const(IdSetLexicon) <code class="code">inputEdgeIdSetLexicon</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns a mapping from an InputEdgeIdSetId to a set of input edge ids.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.minInputEdgeId" id="Graph.minInputEdgeId"><code class="code">minInputEdgeId</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.minInputEdgeId"></span>const InputEdgeId <code class="code">minInputEdgeId</code>(EdgeId <code class="code">e</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the minimum input edge id that was snapped to this edge, or -1 if
 no input edges were snapped (see SiblingPairs::CREATE).  This is
 useful for layers that wish to preserve the input edge ordering as much
 as possible (<code class="code">e</code>.g., to ensure idempotency).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.getMinInputEdgeIds" id="Graph.getMinInputEdgeIds"><code class="code">getMinInputEdgeIds</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.getMinInputEdgeIds"></span>const InputEdgeId[] <code class="code">getMinInputEdgeIds</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns a vector containing the minimum input edge id for every edge.
If an edge has no input ids, kNoInputEdgeId is used.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.getInputEdgeOrder" id="Graph.getInputEdgeOrder"><code class="code">getInputEdgeOrder</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.getInputEdgeOrder"></span>const EdgeId[] <code class="code">getInputEdgeOrder</code>(in InputEdgeId[] <code class="code">input_ids</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns a vector of EdgeIds sorted by minimum input edge id.  This is an
approximation of the input edge ordering.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.LabelFetcher" id="Graph.LabelFetcher"><code class="code">LabelFetcher</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.LabelFetcher"></span>class <code class="code">LabelFetcher</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Convenience class to return the set of labels associated with a given
 graph edge.  Note that due to snapping, one graph edge may correspond to
 several different input edges and will have all of their labels.
 This class is the preferred way to retrieve edge labels.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    The reason this is a class rather than a graph method is because for
 undirected edges, we need to fetch the labels associated with both
 siblings.  This is because only the original edge of the sibling pair has
 labels; the automatically generated sibling edge does not.
  </p>
</div>

</section>
<ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.LabelFetcher.this" id="Graph.LabelFetcher.this"><code class="code">this</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.LabelFetcher.this"></span>this(in Graph <code class="code">g</code>, EdgeType <code class="code">edge_type</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Prepares to fetch labels associated with the given edge type.  For
 EdgeType::UNDIRECTED, labels associated with both edges of the sibling
 pair will be returned.  "<code class="code">edge_type</code>" is a parameter (rather than using
 <code class="code">g</code>.options().<code class="code">edge_type</code>()) so that clients can explicitly control whether
 labels from one or both siblings are returned.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.LabelFetcher.fetch" id="Graph.LabelFetcher.fetch"><code class="code">fetch</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.LabelFetcher.fetch"></span>void <code class="code">fetch</code>(EdgeId <code class="code">e</code>, ref S2Builder.Label[] <code class="code">labels</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the set of <code class="code">labels</code> associated with edge "<code class="code">e</code>" (and also the <code class="code">labels</code>
 associated with the sibling of "<code class="code">e</code>" if edge_type() is UNDIRECTED).
 Labels are sorted and duplicate <code class="code">labels</code> are automatically removed.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    This method uses an output parameter rather than returning by value in
 order to avoid allocating a new vector on every call to this method.
  </p>
</div>

</section>

</div>

</li>
</ul>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.labels" id="Graph.labels"><code class="code">labels</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.labels"></span>const const(IdSetLexicon.IdSet) <code class="code">labels</code>(InputEdgeId <code class="code">id</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the set of <code class="code">labels</code> associated with a given input edge.  Example:
for (Label label : g.<code class="code">labels</code>(input_edge_id)) { ... }
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.labelSetId" id="Graph.labelSetId"><code class="code">labelSetId</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.labelSetId"></span>const LabelSetId <code class="code">labelSetId</code>(InputEdgeId <code class="code">e</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Low-level method that returns an integer representing the set of
 labels associated with a given input edge.  The elements of
 the IdSet can be accessed using label_set_lexicon().
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.labelSetIds" id="Graph.labelSetIds"><code class="code">labelSetIds</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.labelSetIds"></span>const const(LabelSetId[]) <code class="code">labelSetIds</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Low-level method that returns a vector where each element represents the
set of labels associated with a particular output edge.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.labelSetLexicon" id="Graph.labelSetLexicon"><code class="code">labelSetLexicon</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.labelSetLexicon"></span>const const(IdSetLexicon) <code class="code">labelSetLexicon</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns a mapping from a LabelSetId to a set of labels.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.isFullPolygon" id="Graph.isFullPolygon"><code class="code">isFullPolygon</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.isFullPolygon"></span>const bool <code class="code">isFullPolygon</code>(ref S2Error <code class="code">error</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Convenience method that calls is_full_polygon_predicate() to determine
 whether a graph that consists only of polygon degeneracies represents the
 empty polygon or the full polygon (see s2builder.h for details).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.isFullPolygonPredicate" id="Graph.isFullPolygonPredicate"><code class="code">isFullPolygonPredicate</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.isFullPolygonPredicate"></span>const const(IsFullPolygonPredicate) <code class="code">isFullPolygonPredicate</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns a method that determines whether a graph that consists only of
 polygon degeneracies represents the empty polygon or the full polygon
 (see s2builder.h for details).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.getLeftTurnMap" id="Graph.getLeftTurnMap"><code class="code">getLeftTurnMap</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.getLeftTurnMap"></span>const bool <code class="code">getLeftTurnMap</code>(in EdgeId[] <code class="code">in_edge_ids</code>, ref EdgeId[] <code class="code">left_turn_map</code>, ref S2Error <code class="code">error</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns a map "m" that maps each edge e=(v0,v1) to the following outgoing
 edge around "v1" in clockwise order.  \(This corresponds to making a "left
 turn" at the vertex.\)  By starting at a given edge and making only left
 turns, you can construct a loop whose interior does not contain any edges
 in the same connected component.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    If the incoming and outgoing edges around a vertex do not alternate
 perfectly \(e.g., there are two incoming edges in a row\), then adjacent
 \(incoming, outgoing\) pairs are repeatedly matched and removed.  This is
 similar to finding matching parentheses in a string such as "\(\(\)\(\)\)\(\)".
<br><br>
 For sibling edge pairs, the incoming edge is assumed to immediately
 follow the outgoing edge in clockwise order.  Thus a left turn is made
 from an edge to its sibling only if there are no other outgoing edges.
 With respect to the parentheses analogy, a sibling pair is "\(\)".
 Similarly, if there are multiple copies of a sibling edge pair then the
 duplicate incoming and outgoing edges are sorted in alternating order
 \(e.g., "\)\(\)\("\).
<br><br>
 Degenerate edges \(edges from a vertex to itself\) are treated as loops
 consisting of a single edge.  This avoids the problem of deciding the
 connectivity and ordering of such edges when they share a vertex with
 other edges \(possibly including other degenerate edges\).
<br><br>
 If it is not possible to make a left turn from every input edge, this
 method returns <code class="code">false</code> and sets "<code class="code">error</code>" appropriately.  In this situation
 the left turn map is still valid except that any incoming edge where it
 is not possible to make a left turn will have its entry set to -1.
<br><br>
 "<code class="code">in_edge_ids</code>" should be equal to GetInEdgeIds() or GetSiblingMap().
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.canonicalizeLoopOrder" id="Graph.canonicalizeLoopOrder"><code class="code">canonicalizeLoopOrder</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.canonicalizeLoopOrder"></span>static void <code class="code">canonicalizeLoopOrder</code>(in InputEdgeId[] <code class="code">min_input_ids</code>, ref EdgeId[] <code class="code">loop</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Rotates the edges of "<code class="code">loop</code>" if necessary so that the edge(s) with the
 largest input edge ids are last.  This ensures that when an output <code class="code">loop</code>
 is equivalent to an input <code class="code">loop</code>, their cyclic edge orders are the same.
 "<code class="code">min_input_ids</code>" is the output of GetMinInputEdgeIds().
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.canonicalizeVectorOrder" id="Graph.canonicalizeVectorOrder"><code class="code">canonicalizeVectorOrder</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.canonicalizeVectorOrder"></span>static void <code class="code">canonicalizeVectorOrder</code>(in InputEdgeId[] <code class="code">min_input_ids</code>, ref EdgeId[][] <code class="code">chains</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Sorts the given edge <code class="code">chains</code> (i.e., loops or polylines) by the minimum
 input edge id of each <code class="code">chains</code>'s first edge.  This ensures that when the
 output consists of multiple loops or polylines, they are sorted in the
 same order as they were provided in the input.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.EdgeLoop" id="Graph.EdgeLoop"><code class="code">EdgeLoop</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.EdgeLoop"></span>alias <code class="code">EdgeLoop</code> = int[];

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    A loop consisting of a sequence of edges.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.LoopType" id="Graph.LoopType"><code class="code">LoopType</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.LoopType"></span>enum <code class="code">LoopType</code>: int;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Indicates whether loops should be simple cycles (no repeated vertices) or
 circuits (which allow repeated vertices but not repeated edges).  In
 terms of how the loops are built, this corresponds to closing off a loop
 at the first repeated vertex vs. the first repeated edge.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.getDirectedLoops" id="Graph.getDirectedLoops"><code class="code">getDirectedLoops</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.getDirectedLoops"></span>const bool <code class="code">getDirectedLoops</code>(LoopType <code class="code">loop_type</code>, ref EdgeLoop[] <code class="code">loops</code>, ref S2Error <code class="code">error</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Builds <code class="code">loops</code> from a set of directed edges, turning left at each vertex
 until either a repeated vertex (for LoopType::SIMPLE) or a repeated edge
 (for LoopType::CIRCUIT) is found.  (Use LoopType::SIMPLE if you intend to
 construct an S2Loop.)

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Each loop is represented as a sequence of edges.  The edge ordering and
 loop ordering are automatically canonicalized in order to preserve the
 input ordering as much as possible.  Loops are non-crossing provided that
 the graph contains no crossing edges.  If some edges cannot be turned
 into <code class="code">loops</code>, returns <code class="code">false</code> and sets "<code class="code">error</code>" appropriately.
<br><br>
 If any degenerate edges are present, then each such edge is treated as a
 separate loop.  This is mainly useful in conjunction with
 options.degenerate_edges() == DISCARD_EXCESS, in order to build polygons
 that preserve degenerate geometry.


  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">REQUIRES:</span>
options.degenerate_edges() == {DISCARD, DISCARD_EXCESS}

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">REQUIRES:</span>
options.edge_type() == DIRECTED
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.DegenerateBoundaries" id="Graph.DegenerateBoundaries"><code class="code">DegenerateBoundaries</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.DegenerateBoundaries"></span>enum <code class="code">DegenerateBoundaries</code>: int;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Builds loops from a set of directed edges, turning left at each vertex
 until a repeated edge is found (i.e., LoopType::CIRCUIT).  The loops are
 further grouped into connected components, where each component consists
 of one or more loops connected by shared vertices.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    This method is used to build polygon meshes from directed or undirected
 input edges.  To convert the output of this method into a mesh, the
 client must determine how the loops in different components are related
 to each other: for example, several loops from different components may
 bound the same region on the sphere, in which case all of those loops are
 combined into a single polygon.  (See s2shapeutil::BuildPolygonBoundaries
 and s2builderutil::LaxPolygonVectorLayer for details.)
<br><br>
 Note that loops may include both edges of a sibling pair.  When several
 such edges are connected in a chain or a spanning tree, they form a
 zero-area "filament".  The entire loop may be a filament (i.e., a
 degenerate loop with an empty interior), or the loop may have have
 non-empty interior with several filaments that extend inside it, or the
 loop may consist of several "holes" connected by filaments.  These
 filaments do not change the interior of any loop, so if you are only
 interested in point containment then they can safely be removed by
 setting the "degenerate_boundaries" parameter to DISCARD.  (They can't be
 removed by setting (options.sibling_pairs() == DISCARD) because the two
 siblings might belong to different polygons of the mesh.)  Note that you
 can prevent multiple copies of sibling pairs by specifying
 options.duplicate_edges() == MERGE.
<br><br>
 Each loop is represented as a sequence of edges.  The edge ordering and
 loop ordering are automatically canonicalized in order to preserve the
 input ordering as much as possible.  Loops are non-crossing provided that
 the graph contains no crossing edges.  If some edges cannot be turned
 into loops, returns <code class="code">false</code> and sets "error" appropriately.


  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">REQUIRES:</span>
options.degenerate_edges() == { DISCARD, DISCARD_EXCESS }
           (but requires DISCARD if degenerate_boundaries == DISCARD)

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">REQUIRES:</span>
options.sibling_pairs() == { REQUIRE, CREATE }
           [i.e., every edge must have a sibling edge]
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.getUndirectedComponents" id="Graph.getUndirectedComponents"><code class="code">getUndirectedComponents</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.getUndirectedComponents"></span>const bool <code class="code">getUndirectedComponents</code>(LoopType <code class="code">loop_type</code>, ref UndirectedComponent[] <code class="code">components</code>, ref S2Error <code class="code">error</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Builds loops from a set of undirected edges, turning left at each vertex
 until either a repeated vertex (for LoopType::SIMPLE) or a repeated edge
 (for LoopType::CIRCUIT) is found.  The loops are further grouped into
 "<code class="code">components</code>" such that all the loops in a component are connected by
 shared vertices.  Finally, the loops in each component are divided into
 two "complements" such that every edge in one complement is the sibling
 of an edge in the other complement.  This corresponds to the fact that
 given any set of non-crossing undirected loops, there are exactly two
 possible interpretations of the region that those loops represent (where
 one possibility is the complement of the other).  This method does not
 attempt to resolve this ambiguity, but instead returns both possibilities
 for each connected component and lets the client choose among them.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    This method is used to build single polygons.  (Use GetDirectedComponents
 to build polygon meshes, even when the input edges are undirected.)  To
 convert the output of this method into a polygon, the client must choose
 one complement from each component such that the entire set of loops is
 oriented consistently (i.e., they define a region such that the interior
 of the region is always on the left).  The non-chosen complements form
 another set of loops that are also oriented consistently but represent
 the complementary region on the sphere.  Finally, the client needs to
 choose one of these two sets of loops based on heuristics (e.g., the area
 of each region), since both sets of loops are equally valid
 interpretations of the input.
<br><br>
 Each loop is represented as a sequence of edges.  The edge ordering and
 loop ordering are automatically canonicalized in order to preserve the
 input ordering as much as possible.  Loops are non-crossing provided that
 the graph contains no crossing edges.  If some edges cannot be turned
 into loops, returns <code class="code">false</code> and sets "<code class="code">error</code>" appropriately.


  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">REQUIRES:</span>
options.degenerate_edges() == { DISCARD, DISCARD_EXCESS }

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">REQUIRES:</span>
options.edge_type() == UNDIRECTED

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">REQUIRES:</span>
options.siblings_pairs() == { DISCARD, DISCARD_EXCESS, KEEP }
           [since REQUIRE, CREATE convert the edge_type() to DIRECTED]
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.PolylineType" id="Graph.PolylineType"><code class="code">PolylineType</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.PolylineType"></span>enum <code class="code">PolylineType</code>: int;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Indicates whether polylines should be "paths" (which don't allow
 duplicate vertices, except possibly the first and last vertex) or
 "walks" (which allow duplicate vertices and edges).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.EdgePolyline" id="Graph.EdgePolyline"><code class="code">EdgePolyline</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.EdgePolyline"></span>alias <code class="code">EdgePolyline</code> = int[];

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Builds polylines from a set of edges.  If "polyline_type" is PATH, then
 only vertices of indegree and outdegree 1 (or degree 2 in the case of
 undirected edges) will appear in the interior of polylines.  This
 essentially generates one polyline for each edge chain in the graph.  If
 "polyline_type" is WALK, then polylines may pass through the same vertex
 or even the same edge multiple times (if duplicate edges are present),
 and each polyline will be as long as possible.  This option is useful for
 reconstructing a polyline that has been snapped to a lower resolution,
 since snapping can cause edges to become identical.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    This method attempts to preserve the input edge ordering in order to
 implement idempotency, even when there are repeated edges or loops.  This
 is <code class="code">true</code> whether directed or undirected edges are used.  Degenerate edges
 are also handled appropriately.


  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">REQUIRES:</span>
options.sibling_pairs() == { DISCARD, DISCARD_EXCESS, KEEP }
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.processEdges" id="Graph.processEdges"><code class="code">processEdges</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.processEdges"></span>static void <code class="code">processEdges</code>(GraphOptions <code class="code">options</code>, ref Edge[] <code class="code">edges</code>, ref InputEdgeIdSetId[] <code class="code">input_ids</code>, IdSetLexicon <code class="code">id_set_lexicon</code>, ref S2Error <code class="code">error</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Helper Functions for Creating Graphs //////////////////

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Given an unsorted collection of <code class="code">edges</code>, transform them according to the
 given set of GraphOptions.  This includes actions such as discarding
 degenerate <code class="code">edges</code>; merging duplicate <code class="code">edges</code>; and canonicalizing sibling
 edge pairs in several possible ways (e.g. discarding or creating them).
 The output is suitable for passing to the Graph constructor.
<br><br>
 If <code class="code">options</code>.edge_type() == EdgeType::UNDIRECTED, then all input <code class="code">edges</code>
 should already have been transformed into a pair of directed <code class="code">edges</code>.
<br><br>
 "<code class="code">input_ids</code>" is a vector of the same length as "<code class="code">edges</code>" that indicates
 which input <code class="code">edges</code> were snapped to each edge.  This vector is also updated
 appropriately as <code class="code">edges</code> are discarded, merged, etc.
<br><br>
 Note that "<code class="code">options</code>" may be modified by this method: in particular, the
 edge_type() can be changed if sibling_pairs() is CREATE or REQUIRE (see
 the description of S2Builder::GraphOptions).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Graph.filterVertices" id="Graph.filterVertices"><code class="code">filterVertices</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Graph.filterVertices"></span>static S2Point[] <code class="code">filterVertices</code>(in S2Point[] <code class="code">vertices</code>, ref Edge[] <code class="code">edges</code>, ref VertexId[] <code class="code">tmp</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Given a set of <code class="code">vertices</code> and <code class="code">edges</code>, removes all <code class="code">vertices</code> that do not have
 any <code class="code">edges</code> and returned the new, minimal set of <code class="code">vertices</code>.  Also updates
 each edge in "<code class="code">edges</code>" to correspond to the new vertex numbering.  (Note
 that this method does *not* merge duplicate <code class="code">vertices</code>, it simply removes
 <code class="code">vertices</code> of degree zero.)

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    The new vertex ordering is a subsequence of the original ordering,
 therefore if the <code class="code">edges</code> were lexicographically sorted before calling this
 method then they will still be sorted after calling this method.
<br><br>
 The extra argument "<code class="code">tmp</code>" points to temporary storage used by this method.
 All calls to this method from a single thread can reuse the same
 temporary storage.  It should initially point to an empty vector.  This
 can make a big difference to efficiency when this method is called many
 times (e.g. to extract the <code class="code">vertices</code> for different layers), since the
 incremental running time for each layer becomes O(<code class="code">edges</code>.size()) rather
 than O(<code class="code">vertices</code>.size() + <code class="code">edges</code>.size()).
  </p>
</div>

</section>

</div>

</li>
</ul>

</div>

</li>
</ul>
  </div>
</section>
</section>
      </article>
    </div>
  </body>
</html>
