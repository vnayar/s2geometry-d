<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>
		<title>Class S2Loop</title>
		<link rel="stylesheet" type="text/css" href="../../styles/ddox.css"/>
		<link rel="stylesheet" href="../../prettify/prettify.css" type="text/css"/>
		<script type="text/javascript" src="../../scripts/jquery.js">/**/</script><script type="text/javascript" src="../../scripts/ddox.js">/**/</script>
	</head>
	<body onload="setupDdox();">
		<nav id="main-nav">
			<noscript>
				<p style="color: red">The search functionality needs JavaScript enabled</p>
			</noscript>
			<div id="symbolSearchPane" style="display: none">
				<form action="#" method="GET">
					<input id="symbolSearch" type="text" name="q" placeholder="Search for symbols" autocomplete="off" onchange="performSymbolSearch(40);" onkeypress="this.onchange();" onpaste="this.onchange();" oninput="this.onchange();"/>
				</form>
				<ul id="symbolSearchResults" class="symbolList" style="display: none"></ul><script type="application/javascript" src="../../symbols.js"></script><script type="application/javascript">var symbolSearchRootDir = "../../";
$('#symbolSearchPane').show();</script>
			</div>
			<ul class="tree-view">
				<li class="tree-view ">
					<div class="package ">s2
					</div>
			<ul class="tree-view">
				<li class="tree-view collapsed">
					<div class="package ">base
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../s2/base/spinlock.html">spinlock</a>
					</div>
				</li>
			</ul>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/r1interval.html">r1interval</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s1angle.html">s1angle</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2builder.html">s2builder</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2cap.html">s2cap</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2cell.html">s2cell</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2cell_id.html">s2cell_id</a>
					</div>
				</li>
				<li>
					<div class="module selected">
						<a href="../../s2/s2loop.html">s2loop</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2polygon.html">s2polygon</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2region.html">s2region</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2shape.html">s2shape</a>
					</div>
				</li>
			</ul>
				</li>
			</ul>
		</nav>
		<div id="main-contents">
			<h1>Class S2Loop</h1><p>An S2Loop represents a simple spherical polygon.  It consists of a single
 chain of vertices where the first vertex is implicitly connected to the
 last. All loops are defined to have a CCW orientation, i.e. the interior of
 the loop is on the left side of the edges.  This implies that a clockwise
 loop enclosing a small area is interpreted to be a CCW loop enclosing a
 very large area.
</p>
			<div class="prototype">
				<code class="lang-d">
					<div class="single-prototype">
			<span class="kwd">class</span> <span class="typ">S2Loop</span>
			<br>&nbsp;&nbsp;: <a href="../../s2/s2region/S2Region.html"><span class="typ">S2Region</span></a>
			<span class="pun">;</span>
					</div>
				</code>
			</div>
			<section><p>Loops are not allowed to have any duplicate vertices (whether adjacent or
 not).  Non-adjacent edges are not allowed to intersect, and furthermore edges
 of length 180 degrees are not allowed (i.e., adjacent vertices cannot be
 antipodal).  Loops must have at least 3 vertices (except for the "empty" and
 "full" loops discussed below).  Although these restrictions are not enforced
 in optimized code, you may get unexpected results if they are violated.
</p>

<p> There are two special loops: the "empty" loop contains no points, while the
 "full" loop contains all points.  These loops do not have any edges, but to
 preserve the invariant that every loop can be represented as a vertex
 chain, they are defined as having exactly one vertex each (see kEmpty and
 kFull).
</p>

<p> Point containment of loops is defined such that if the sphere is subdivided
 into faces (loops), every point is contained by exactly one face.  This
 implies that loops do not necessarily contain their vertices.
</p>
</section>

			<section><h2>Constructors</h2>
				<table>
					<col class="caption"/>
					<tr>
						<th>Name</th><th>Description</th>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.this.html" class="public">
								<code>this</code>
							</a>
						</td>
						<td>Default constructor.  The loop must be initialized by calling Init() or
Decode() before it is used.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.this.html" class="public">
								<code>this</code>
							</a>
						</td>
						<td>Convenience constructor that calls Init() with the given vertices.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.this.html" class="public">
								<code>this</code>
							</a>
						</td>
						<td>Construct a loop corresponding to the given cell.
</td>
					</tr>
				</table>
			</section>
			<section><h2>Properties</h2>
				<table>
					<col class="caption"/>
					<tr>
						<th>Name</th><th>Type</th><th>Description</th>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.s2DebugOverride.html" class="public property"><code>s2DebugOverride</code></a><span class="tableEntryAnnotation">[set]</span>
						</td>
						<td class="typecol"><code class="prettyprint lang-d"><span class="pln">s2<wbr/></span><span class="pun">.</span><span class="pln">s2debug<wbr/></span><span class="pun">.</span><span class="typ">S2Debug</span></code></td><td>Allows overriding the automatic validity checks controlled by the
     --s2debug flag.  If this flag is true, then loops are automatically
     checked for validity as they are initialized.  The main reason to disable
     this flag is if you intend to call IsValid() explicitly, like this:
</td>
					</tr>
				</table>
			</section>
			<section><h2>Methods</h2>
				<table>
					<col class="caption"/>
					<tr>
						<th>Name</th><th>Description</th>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.boundaryApproxEquals.html" class="public">
								<code>boundaryApproxEquals</code>
							</a>
						</td>
						<td>Returns true if two loops have the same boundary except for vertex
     perturbations.  More precisely, the vertices in the two loops must be in
     the same cyclic order, and corresponding vertex pairs must be separated
     by no more than "max_error".
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.boundaryEquals.html" class="public">
								<code>boundaryEquals</code>
							</a>
						</td>
						<td>Returns true if two loops have the same boundary.  This is true if and
     only if the loops have the same vertices in the same cyclic order (i.e.,
     the vertices may be cyclically rotated).  The empty and full loops are
     considered to have different boundaries.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.boundaryNear.html" class="public">
								<code>boundaryNear</code>
							</a>
						</td>
						<td>Returns true if the two loop boundaries are within "max_error" of each
     other along their entire lengths.  The two loops may have different
     numbers of vertices.  More precisely, this method returns true if the two
     loops have parameterizations a:[0,1] -&gt; S^2, b:[0,1] -&gt; S^2 such that
     distance(a(t), b(t)) &lt;= max_error for all t.  You can think of this as
     testing whether it is possible to drive two cars all the way around the
     two loops such that no car ever goes backward and the cars are always
     within "max_error" of each other.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.clone.html" class="public">
								<code>clone</code>
							</a>
						</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.compareBoundary.html" class="public">
								<code>compareBoundary</code>
							</a>
						</td>
						<td>Return +1 if A contains the boundary of B, -1 if A excludes the boundary
     of B, and 0 if the boundaries of A and B cross.  Shared edges are handled
     as follows: If XY is a shared edge, define Reversed(XY) to be true if XY
     appears in opposite directions in A and B.  Then A contains XY if and
     only if Reversed(XY) == B-&gt;is_hole().  (Intuitively, this checks whether
     A contains a vanishingly small region extending from the boundary of B
     toward the interior of the polygon to which loop B belongs.)
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.contains.html" class="public">
								<code>contains</code>
							</a>
						</td>
						<td>Returns true if the region contained by this loop is a superset of the
     region contained by the given other loop.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.containsNested.html" class="public">
								<code>containsNested</code>
							</a>
						</td>
						<td>Given two loops of a polygon, return true if A contains B.  This version
     of Contains() is cheap because it does not test for edge intersections.
     The loops must meet all the S2Polygon requirements; for example this
     implies that their boundaries may not cross or have any shared edges
     (although they may have shared vertices).
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.decode.html" class="public">
								<code>decode</code>
							</a>
						</td>
						<td>Decodes a loop encoded with Encode() or the private method
     EncodeCompressed() (used by the S2Polygon encoder).  Returns true on
     success.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.depth.html" class="public">
								<code>depth</code>
							</a>
						</td>
						<td>The depth of a loop is defined as its nesting level within its containing
     polygon.  "Outer shell" loops have depth 0, holes within those loops have
     depth 1, shells within those holes have depth 2, etc.  This field is only
     used by the S2Polygon implementation.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.empty.html" class="public">
								<code>empty</code>
							</a>
						</td>
						<td>A special vertex chain of length 1 that creates an empty loop (i.e., a
     loop with no edges that contains no points).  Example usage:
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.encode.html" class="public">
								<code>encode</code>
							</a>
						</td>
						<td>Appends a serialized representation of the S2Loop to "encoder".
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.equals.html" class="public">
								<code>equals</code>
							</a>
						</td>
						<td>Returns true if two loops have the same vertices in the same linear order
     (i.e., cyclic rotations are not allowed).
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.findValidationError.html" class="public">
								<code>findValidationError</code>
							</a>
						</td>
						<td>Returns true if this is *not* a valid loop and sets "error"
     appropriately.  Otherwise returns false and leaves "error" unchanged.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.findValidationErrorNoIndex.html" class="public">
								<code>findValidationErrorNoIndex</code>
							</a>
						</td>
						<td>Like FindValidationError(), but skips any checks that would require
     building the S2ShapeIndex (i.e., self-intersection tests).  This is used
     by the S2Polygon implementation, which uses its own index to check for
     loop self-intersections.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.full.html" class="public">
								<code>full</code>
							</a>
						</td>
						<td>A special vertex chain of length 1 that creates a full loop (i.e., a loop
with no edges that contains all points).  See kEmpty() for details.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.getArea.html" class="public">
								<code>getArea</code>
							</a>
						</td>
						<td>Return the area of the loop interior, i.e. the region on the left side of
     the loop.  The return value is between 0 and 4*Pi.  (Note that the return
     value is not affected by whether this loop is a "hole" or a "shell".)
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.getCapBound.html" class="public">
								<code>getCapBound</code>
							</a>
						</td>
						<td>GetRectBound() returns essentially tight results, while GetCapBound()
     might have a lot of extra padding.  Both bounds are conservative in that
     if the loop contains a point P, then the bound contains P also.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.getCentroid.html" class="public">
								<code>getCentroid</code>
							</a>
						</td>
						<td>Returns the true centroid of the loop multiplied by the area of the loop
     (see s2centroids.h for details on centroids).  The result is not unit
     length, so you may want to normalize it.  Also note that in general, the
     centroid may not be contained by the loop.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.getDistance.html" class="public">
								<code>getDistance</code>
							</a>
						</td>
						<td>Returns the distance from the given point to the loop interior.  If the
     loop is empty, return S1Angle::Infinity().  "x" should be unit length.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.getDistanceToBoundary.html" class="public">
								<code>getDistanceToBoundary</code>
							</a>
						</td>
						<td>Returns the distance from the given point to the loop boundary.  If the
     loop is empty or full, return S1Angle::Infinity() (since the loop has no
     boundary).  "x" should be unit length.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.getSurfaceIntegral.html" class="public">
								<code>getSurfaceIntegral</code>
							</a>
						</td>
						<td>This method computes the oriented surface integral of some quantity f(x)
     over the loop interior, given a function f_tri(A,B,C) that returns the
     corresponding integral over the spherical triangle ABC.  Here "oriented
     surface integral" means:
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.getTurningAngle.html" class="public">
								<code>getTurningAngle</code>
							</a>
						</td>
						<td>Returns the sum of the turning angles at each vertex.  The return value is
     positive if the loop is counter-clockwise, negative if the loop is
     clockwise, and zero if the loop is a great circle.  Degenerate and
     nearly-degenerate loops are handled consistently with s2pred::Sign().
     So for example, if a loop has zero area (i.e., it is a very small CCW
     loop) then the turning angle will always be negative.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.getTurningAngleMaxError.html" class="public">
								<code>getTurningAngleMaxError</code>
							</a>
						</td>
						<td>Return the maximum error in GetTurningAngle().  The return value is not
     constant; it depends on the loop.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.initialize.html" class="public">
								<code>initialize</code>
							</a>
						</td>
						<td>Initialize a loop with given vertices.  The last vertex is implicitly
     connected to the first.  All points should be unit length.  Loops must
     have at least 3 vertices (except for the "empty" and "full" loops, see
     kEmpty and kFull).  This method may be called multiple times.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.intersects.html" class="public">
								<code>intersects</code>
							</a>
						</td>
						<td>Returns true if the region contained by this loop intersects the region
     contained by the given other loop.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.invert.html" class="public">
								<code>invert</code>
							</a>
						</td>
						<td>Reverse the order of the loop vertices, effectively complementing the
     region represented by the loop.  For example, the loop ABCD (with edges
     AB, BC, CD, DA) becomes the loop DCBA (with edges DC, CB, BA, AD).
     Notice that the last edge is the same in both cases except that its
     direction has been reversed.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.isEmpty.html" class="public">
								<code>isEmpty</code>
							</a>
						</td>
						<td>Returns true if this is the special "empty" loop that contains no points.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.isEmptyOrFull.html" class="public">
								<code>isEmptyOrFull</code>
							</a>
						</td>
						<td>Returns true if this loop is either "empty" or "full".
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.isFull.html" class="public">
								<code>isFull</code>
							</a>
						</td>
						<td>Returns true if this is the special "full" loop that contains all points.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.isHole.html" class="public">
								<code>isHole</code>
							</a>
						</td>
						<td>Returns true if this loop represents a hole in its containing polygon.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.isNormalized.html" class="public">
								<code>isNormalized</code>
							</a>
						</td>
						<td>Return true if the loop area is at most 2*Pi.  Degenerate loops are
     handled consistently with s2pred::Sign(), i.e., if a loop can be
     expressed as the union of degenerate or nearly-degenerate CCW triangles,
     then it will always be considered normalized.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.isValid.html" class="public">
								<code>isValid</code>
							</a>
						</td>
						<td>Returns true if this is a valid loop.  Note that validity is checked
     automatically during initialization when --s2debug is enabled (true by
     default in debug binaries).
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.makeRegularLoop.html" class="public">
								<code>makeRegularLoop</code>
							</a>
						</td>
						<td>Constructs a regular polygon with the given number of vertices, all
     located on a circle of the specified radius around "center".  The radius
     is the actual distance from "center" to each vertex.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.makeRegularLoop.html" class="public">
								<code>makeRegularLoop</code>
							</a>
						</td>
						<td>Like the function above, but this version constructs a loop centered
     around the z-axis of the given coordinate frame, with the first vertex in
     the direction of the positive x-axis.  (This allows the loop to be
     rotated for testing purposes.)
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.normalize.html" class="public">
								<code>normalize</code>
							</a>
						</td>
						<td>Invert the loop if necessary so that the area enclosed by the loop is at most 2*Pi.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.orientedVertex.html" class="public">
								<code>orientedVertex</code>
							</a>
						</td>
						<td>Like vertex(), but this method returns vertices in reverse order if the
     loop represents a polygon hole.  For example, arguments 0, 1, 2 are
     mapped to vertices n-1, n-2, n-3, where n == num_vertices().  This
     ensures that the interior of the polygon is always to the left of the
     vertex chain.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.project.html" class="public">
								<code>project</code>
							</a>
						</td>
						<td>If the given point is contained by the loop, return it.  Otherwise return
     the closest point on the loop boundary.  If the loop is empty, return the
     input argument.  Note that the result may or may not be contained by the
     loop.  "x" should be unit length.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.projectToBoundary.html" class="public">
								<code>projectToBoundary</code>
							</a>
						</td>
						<td>Return the closest point on the loop boundary to the given point.  If the
     loop is empty or full, return the input argument (since the loop has no
     boundary).  "x" should be unit length.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.sign.html" class="public">
								<code>sign</code>
							</a>
						</td>
						<td>The sign of a loop is -1 if the loop represents a hole in its containing
     polygon, and +1 otherwise.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.spaceUsed.html" class="public">
								<code>spaceUsed</code>
							</a>
						</td>
						<td>Returns the total number of bytes used by the loop.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.vertex.html" class="public">
								<code>vertex</code>
							</a>
						</td>
						<td>For convenience, we make two entire copies of the vertex list available:
     vertex(n..2*n-1) is mapped to vertex(0..n-1), where n == num_vertices().
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2region/S2Region.clone.html" class="public inherited">
								<code>clone</code>
							</a>
						</td>
						<td>Returns a deep copy of the region.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2region/S2Region.contains.html" class="public inherited">
								<code>contains</code>
							</a>
						</td>
						<td>Returns true if and only if the given point is contained by the region.
 The point 'p' is generally required to be unit length, although some
 subtypes may relax this restriction.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2region/S2Region.contains.html" class="public inherited">
								<code>contains</code>
							</a>
						</td>
						<td>Returns true if the region completely contains the given cell, otherwise
 returns false.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2region/S2Region.getCapBound.html" class="public inherited">
								<code>getCapBound</code>
							</a>
						</td>
						<td>Returns a bounding spherical cap that contains the region.  The bound may
 not be tight.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2region/S2Region.getCellUnionBound.html" class="public inherited">
								<code>getCellUnionBound</code>
							</a>
						</td>
						<td>Returns a small collection of S2CellIds whose union covers the region.
 The cells are not sorted, may have redundancies (such as cells that
 contain other cells), and may cover much more area than necessary.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2region/S2Region.getRectBound.html" class="public inherited">
								<code>getRectBound</code>
							</a>
						</td>
						<td>Returns a bounding latitude-longitude rectangle that contains the region.
 The bound may not be tight.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2region/S2Region.mayIntersect.html" class="public inherited">
								<code>mayIntersect</code>
							</a>
						</td>
						<td>If this method returns false, the region does not intersect the given
 cell.  Otherwise, either region intersects the cell, or the intersection
 relationship could not be determined.
</td>
					</tr>
				</table>
			</section>
			<section><h2>Inner classes</h2>
				<table>
					<col class="caption"/>
					<tr>
						<th>Name</th><th>Description</th>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2loop/S2Loop.Shape.html" class="public">
								<code>Shape</code>
							</a>
						</td>
						<td>Wrapper class for indexing a loop (see S2ShapeIndex).  Once this object
     is inserted into an S2ShapeIndex it is owned by that index, and will be
     automatically deleted when no longer needed by the index.  Note that this
     class does not take ownership of the loop itself (see OwningShape below).
     You can also subtype this class to store additional data (see S2Shape for
     details).
</td>
					</tr>
				</table>
			</section>
			<section><h2>Note</h2>
<p>The reason that duplicate vertices and intersecting edges are not
 allowed is that they make it harder to define and implement loop
 relationships, e.g. whether one loop contains another.  If your data does
 not satisfy these restrictions, you can use S2Builder to normalize it.
</p>
</section>
<section><h2>TODO</h2>
<p>Convert logic to use a ForwardRange rather than making a copy of its vertices.
</p>
</section>

			<footer>
				<table class="license-info">
					<tr>
						<th>Authors</th>
						<td>
							<p>ericv@google.com (Eric Veach), madric@gmail.com (Vijay Nayar)
</p>

						</td>
					</tr>
					<tr>
						<th>Copyright</th>
						<td>
							<p>2005 Google Inc. All Rights Reserved.
</p>

						</td>
					</tr>
					<tr>
						<th>License</th>
						<td>
							<p>Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
</p>

<p>   <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
</p>

<p>   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS-IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</p>

						</td>
					</tr>
				</table>
				<p class="faint">Generated using the DDOX documentation generator</p>
			</footer>
		</div>
	</body>
</html>