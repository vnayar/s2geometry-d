<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>
		<title>Struct S2CellId</title>
		<link rel="stylesheet" type="text/css" href="../../styles/ddox.css"/>
		<link rel="stylesheet" href="../../prettify/prettify.css" type="text/css"/>
		<script type="text/javascript" src="../../scripts/jquery.js">/**/</script><script type="text/javascript" src="../../scripts/ddox.js">/**/</script>
	</head>
	<body onload="setupDdox();">
		<nav id="main-nav">
			<noscript>
				<p style="color: red">The search functionality needs JavaScript enabled</p>
			</noscript>
			<div id="symbolSearchPane" style="display: none">
				<form action="#" method="GET">
					<input id="symbolSearch" type="text" name="q" placeholder="Search for symbols" autocomplete="off" onchange="performSymbolSearch(40);" onkeypress="this.onchange();" onpaste="this.onchange();" oninput="this.onchange();"/>
				</form>
				<ul id="symbolSearchResults" class="symbolList" style="display: none"></ul><script type="application/javascript" src="../../symbols.js"></script><script type="application/javascript">var symbolSearchRootDir = "../../";
$('#symbolSearchPane').show();</script>
			</div>
			<ul class="tree-view">
				<li class="tree-view ">
					<div class="package ">s2
					</div>
			<ul class="tree-view">
				<li class="tree-view collapsed">
					<div class="package ">base
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../s2/base/spinlock.html">spinlock</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">builder
					</div>
			<ul class="tree-view">
				<li class="tree-view collapsed">
					<div class="package ">util
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../s2/builder/util/s2polygon_layer.html">s2polygon_layer</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/builder/util/s2polyline_layer.html">s2polyline_layer</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/builder/util/s2polyline_vector_layer.html">s2polyline_vector_layer</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/builder/util/snap_functions.html">snap_functions</a>
					</div>
				</li>
			</ul>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/builder/graph.html">graph</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/builder/layer.html">layer</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">shapeutil
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../s2/shapeutil/contains_brute_force.html">contains_brute_force</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/shapeutil/count_edges.html">count_edges</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/shapeutil/edge_iterator.html">edge_iterator</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/shapeutil/get_reference_point.html">get_reference_point</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/shapeutil/range_iterator.html">range_iterator</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/shapeutil/shape_edge.html">shape_edge</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/shapeutil/shape_edge_id.html">shape_edge_id</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/shapeutil/visit_crossing_edge_pairs.html">visit_crossing_edge_pairs</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">strings
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../s2/strings/serialize.html">serialize</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">util
					</div>
			<ul class="tree-view">
				<li class="tree-view collapsed">
					<div class="package ">coding
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../s2/util/coding/coder.html">coder</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">container
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../s2/util/container/btree.html">btree</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/util/container/btree_map.html">btree_map</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/util/container/dense_hash_set.html">dense_hash_set</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/util/container/dense_hash_table.html">dense_hash_table</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/util/container/rbtree_map.html">rbtree_map</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">hash
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../s2/util/hash/mix.html">mix</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">log
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../s2/util/log/logger.html">logger</a>
					</div>
				</li>
			</ul>
				</li>
				<li class="tree-view collapsed">
					<div class="package ">math
					</div>
			<ul class="tree-view">
				<li>
					<div class="module ">
						<a href="../../s2/util/math/exactfloat.html">exactfloat</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/util/math/mathutil.html">mathutil</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/util/math/matrix3x3.html">matrix3x3</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/util/math/s2const.html">s2const</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/util/math/vector.html">vector</a>
					</div>
				</li>
			</ul>
				</li>
			</ul>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/id_set_lexicon.html">id_set_lexicon</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/logger.html">logger</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/mutable_s2shape_index.html">mutable_s2shape_index</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/r1interval.html">r1interval</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/r2point.html">r2point</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/r2rect.html">r2rect</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s1angle.html">s1angle</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s1chord_angle.html">s1chord_angle</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s1interval.html">s1interval</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2boolean_operation.html">s2boolean_operation</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2builder.html">s2builder</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2cap.html">s2cap</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2cell.html">s2cell</a>
					</div>
				</li>
				<li>
					<div class="module selected">
						<a href="../../s2/s2cell_id.html">s2cell_id</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2cell_union.html">s2cell_union</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2centroids.html">s2centroids</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2closest_edge_query.html">s2closest_edge_query</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2closest_edge_query_base.html">s2closest_edge_query_base</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2closest_point_query.html">s2closest_point_query</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2closest_point_query_base.html">s2closest_point_query_base</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2contains_point_query.html">s2contains_point_query</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2contains_vertex_query.html">s2contains_vertex_query</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2coords.html">s2coords</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2crossing_edge_query.html">s2crossing_edge_query</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2debug.html">s2debug</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2distance_target.html">s2distance_target</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2edge_clipping.html">s2edge_clipping</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2edge_crosser.html">s2edge_crosser</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2edge_crossings.html">s2edge_crossings</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2edge_distances.html">s2edge_distances</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2edge_vector_shape.html">s2edge_vector_shape</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2error.html">s2error</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2latlng.html">s2latlng</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2latlng_rect.html">s2latlng_rect</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2latlng_rect_bounder.html">s2latlng_rect_bounder</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2lax_loop_shape.html">s2lax_loop_shape</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2lax_polygon_shape.html">s2lax_polygon_shape</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2lax_polyline_shape.html">s2lax_polyline_shape</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2loop.html">s2loop</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2measures.html">s2measures</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2metrics.html">s2metrics</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2min_distance_targets.html">s2min_distance_targets</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2padded_cell.html">s2padded_cell</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2point.html">s2point</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2point_compression.html">s2point_compression</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2point_index.html">s2point_index</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2point_vector_shape.html">s2point_vector_shape</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2pointutil.html">s2pointutil</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2polygon.html">s2polygon</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2polyline.html">s2polyline</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2polyline_simplifier.html">s2polyline_simplifier</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2predicates.html">s2predicates</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2region.html">s2region</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2region_coverer.html">s2region_coverer</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2shape.html">s2shape</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2shape_index.html">s2shape_index</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2shape_index_region.html">s2shape_index_region</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2text_format.html">s2text_format</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/s2wedge_relations.html">s2wedge_relations</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/sequence_lexicon.html">sequence_lexicon</a>
					</div>
				</li>
				<li>
					<div class="module ">
						<a href="../../s2/value_lexicon.html">value_lexicon</a>
					</div>
				</li>
			</ul>
				</li>
			</ul>
		</nav>
		<div id="main-contents">
			<h1>Struct S2CellId</h1><p>An S2CellId is a 64-bit unsigned integer that uniquely identifies a
 cell in the S2 cell decomposition.  It has the following format:
</p>
			<div class="prototype">
				<code class="lang-d">
					<div class="single-prototype">
			<span class="kwd">struct</span> <span class="typ">S2CellId</span>
			<span class="pun">;</span>
					</div>
				</code>
			</div>
			<section><p>id = [face][face_pos]
</p>
</section>

			<section><h2>Constructors</h2>
				<table>
					<col class="caption"/>
					<tr>
						<th>Name</th><th>Description</th>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.this.html" class="public">
								<code>this</code>
							</a>
						</td>
						<td>Construct a cell from a raw numerical S2 Cell ID.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.this.html" class="public">
								<code>this</code>
							</a>
						</td>
						<td>Construct a leaf cell containing the given point "p".  Usually there is
 is exactly one such cell, but for points along the edge of a cell, any
 adjacent cell may be (deterministically) chosen.  This is because
 S2CellIds are considered to be closed sets.  The returned cell will
 always contain the given point, i.e.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.this.html" class="public">
								<code>this</code>
							</a>
						</td>
						<td>Constructs a cell from a latitude-longitude coordinate.
</td>
					</tr>
				</table>
			</section>
			<section><h2>Fields</h2>
				<table>
					<col class="caption"/>
					<tr>
						<th>Name</th><th>Type</th><th>Description</th>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.FACE_BITS.html" class="public"><code>FACE_BITS</code></a>
						</td>
						<td class="typecol"><code class="prettyprint lang-d"><span class="kwd">immutable</span><span class="pun">(</span><span class="typ">int</span><span class="pun">)</span></code></td><td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.MAX_LEVEL.html" class="public"><code>MAX_LEVEL</code></a>
						</td>
						<td class="typecol"><code class="prettyprint lang-d"><span class="kwd">immutable</span><span class="pun">(</span><span class="typ">int</span><span class="pun">)</span></code></td><td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.MAX_SIZE.html" class="public"><code>MAX_SIZE</code></a>
						</td>
						<td class="typecol"><code class="prettyprint lang-d"><span class="kwd">immutable</span><span class="pun">(</span><span class="typ">int</span><span class="pun">)</span></code></td><td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.NUM_FACES.html" class="public"><code>NUM_FACES</code></a>
						</td>
						<td class="typecol"><code class="prettyprint lang-d"><span class="kwd">immutable</span><span class="pun">(</span><span class="typ">int</span><span class="pun">)</span></code></td><td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.POS_BITS.html" class="public"><code>POS_BITS</code></a>
						</td>
						<td class="typecol"><code class="prettyprint lang-d"><span class="kwd">immutable</span><span class="pun">(</span><span class="typ">int</span><span class="pun">)</span></code></td><td></td>
					</tr>
				</table>
			</section>
			<section><h2>Properties</h2>
				<table>
					<col class="caption"/>
					<tr>
						<th>Name</th><th>Type</th><th>Description</th>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.id.html" class="public property"><code>id</code></a><span class="tableEntryAnnotation">[get]</span>
						</td>
						<td class="typecol"><code class="prettyprint lang-d"><span class="typ">ulong</span></code></td><td>The 64-bit unique identifier for this cell.
</td>
					</tr>
				</table>
			</section>
			<section><h2>Methods</h2>
				<table>
					<col class="caption"/>
					<tr>
						<th>Name</th><th>Description</th>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.advance.html" class="public">
								<code>advance</code>
							</a>
						</td>
						<td>This method advances or retreats the indicated number of steps along the
 Hilbert curve at the current level, and returns the new position.  The
 position is never advanced past End() or before Begin().
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.advanceWrap.html" class="public">
								<code>advanceWrap</code>
							</a>
						</td>
						<td>This method advances or retreats the indicated number of steps along the
 Hilbert curve at the current level, and returns the new position.  The
 position wraps between the first and last faces as necessary.  The input
 must be a valid cell id.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.appendAllNeighbors.html" class="public">
								<code>appendAllNeighbors</code>
							</a>
						</td>
						<td>Append all neighbors of this cell at the given level to "output".  Two
 cells X and Y are neighbors if their boundaries intersect but their
 interiors do not.  In particular, two cells that intersect at a single
 point are neighbors.  Note that for cells adjacent to a face vertex, the
 same neighbor may be appended more than once.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.appendVertexNeighbors.html" class="public">
								<code>appendVertexNeighbors</code>
							</a>
						</td>
						<td>Returns the neighbors of closest vertex to this cell at the given level,
 by appending them to "output".  Normally there are four neighbors, but
 the closest vertex may only have three neighbors if it is one of the 8
 cube vertices.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.begin.html" class="public">
								<code>begin</code>
							</a>
						</td>
						<td>Iterator-style methods for traversing all the cells along the Hilbert
 curve at a given level (across all 6 faces of the cube).  Note that the
 end value is exclusive (just like standard STL iterators), and is not a
 valid cell id.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.child.html" class="public">
								<code>child</code>
							</a>
						</td>
						<td>Returns the immediate child of this cell at the given traversal order
 position (in the range 0 to 3).  This cell must not be a leaf cell.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.childBegin.html" class="public">
								<code>childBegin</code>
							</a>
						</td>
						<td>Iterator-style methods for traversing the immediate children of a cell or
 all of the children at a given level (greater than or equal to the current
 level).  Note that the end value is exclusive, just like standard STL
 iterators, and may not even be a valid cell id.  You should iterate using
 code like this:
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.childBegin.html" class="public">
								<code>childBegin</code>
							</a>
						</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.childEnd.html" class="public">
								<code>childEnd</code>
							</a>
						</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.childEnd.html" class="public">
								<code>childEnd</code>
							</a>
						</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.childPosition.html" class="public">
								<code>childPosition</code>
							</a>
						</td>
						<td>Return the child position (0..3) of this cell within its parent.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.childPosition.html" class="public">
								<code>childPosition</code>
							</a>
						</td>
						<td>Return the child position (0..3) of this cell's ancestor at the given
 level within its parent.  For example, child_position(1) returns the
 position of this cell's level-1 ancestor within its top-level face cell.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.contains.html" class="public">
								<code>contains</code>
							</a>
						</td>
						<td>Returns true if the given cell is contained within this one.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.decode.html" class="public">
								<code>decode</code>
							</a>
						</td>
						<td>Decodes an S2CellId encoded by Encode(). Returns true on success.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.distanceFromBegin.html" class="public">
								<code>distanceFromBegin</code>
							</a>
						</td>
						<td>Returns the number of steps that this cell is from Begin(level()). The
 return value is always non-negative.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.encode.html" class="public">
								<code>encode</code>
							</a>
						</td>
						<td>Use encoder to generate a serialized representation of this cell id.
 Can also encode an invalid cell.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.end.html" class="public">
								<code>end</code>
							</a>
						</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.expandedByDistanceUV.html" class="public">
								<code>expandedByDistanceUV</code>
							</a>
						</td>
						<td>Expands a rectangle in (u,v)-space so that it contains all points within
 the given distance of the boundary, and return the smallest such
 rectangle.  If the distance is negative, then instead shrink this
 rectangle so that it excludes all points within the given absolute
 distance of the boundary.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.face.html" class="public">
								<code>face</code>
							</a>
						</td>
						<td>Which cube face this cell belongs to, in the range 0..5.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.fromDebugString.html" class="public">
								<code>fromDebugString</code>
							</a>
						</td>
						<td>Converts a string in the format returned by ToString() to an S2CellId.
 Returns S2CellId::None() if the string could not be parsed.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.fromFace.html" class="public">
								<code>fromFace</code>
							</a>
						</td>
						<td>Return the cell corresponding to a given S2 cube face.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.fromFaceIJ.html" class="public">
								<code>fromFaceIJ</code>
							</a>
						</td>
						<td>Returns a leaf cell given its cube face (range 0..5) and
 i- and j-coordinates (see s2coords.h).
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.fromFacePosLevel.html" class="public">
								<code>fromFacePosLevel</code>
							</a>
						</td>
						<td>Returns a cell given its face \(range 0..5\), Hilbert curve position within
 that face \(an unsigned integer with S2CellId::POS_BITS bits\), and level
 \(range 0..MAX_LEVEL\).  The given position will be modified to correspond
 to the Hilbert curve position at the center of the returned cell.  This
 is a static function rather than a constructor in order to indicate what
 the arguments represent.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.fromToken.html" class="public">
								<code>fromToken</code>
							</a>
						</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.getBoundST.html" class="public">
								<code>getBoundST</code>
							</a>
						</td>
						<td>Returns the bounds of this cell in (s,t)-space.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.getBoundUV.html" class="public">
								<code>getBoundUV</code>
							</a>
						</td>
						<td>Returns the bounds of this cell in (u,v)-space.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.getCenterSiTi.html" class="public">
								<code>getCenterSiTi</code>
							</a>
						</td>
						<td>Returns the (face, si, ti) coordinates of the center of the cell.  Note
 that although (si,ti) coordinates span the range [0,2**31] in general,
 the cell center coordinates are always in the range [1,2**31-1] and
 therefore can be represented using a signed 32-bit integer.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.getCenterST.html" class="public">
								<code>getCenterST</code>
							</a>
						</td>
						<td>Returns the center of the cell in (s,t) coordinates (see s2coords.d).
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.getCenterUV.html" class="public">
								<code>getCenterUV</code>
							</a>
						</td>
						<td>Returns the center of the cell in (u,v) coordinates (see s2coords.h).
 Note that the center of the cell is defined as the point at which it is
 recursively subdivided into four children; in general, it is not at the
 midpoint of the (u,v) rectangle covered by the cell.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.getCommonAncestorLevel.html" class="public">
								<code>getCommonAncestorLevel</code>
							</a>
						</td>
						<td>Returns the level of the lowest common ancestor of this cell and "other",
 that is, the maximum level such that parent(level) == other.parent(level).
 Returns -1 if the two cells do not have any common ancestor (i.e., they
 are from different faces).
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.getEdgeNeighbors.html" class="public">
								<code>getEdgeNeighbors</code>
							</a>
						</td>
						<td>Returns the four cells that are adjacent across the cell's four edges.
 Neighbors are returned in the order defined by S2Cell::GetEdge.  All
 neighbors are guaranteed to be distinct.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.getSizeIJ.html" class="public">
								<code>getSizeIJ</code>
							</a>
						</td>
						<td>Returns the edge length of this cell in (i,j)-space.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.getSizeIJ.html" class="public">
								<code>getSizeIJ</code>
							</a>
						</td>
						<td>Like getSizeIJ(), but returns the size of cells at the given level.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.getSizeST.html" class="public">
								<code>getSizeST</code>
							</a>
						</td>
						<td>Returns the edge length of this cell in (s,t)-space.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.getSizeST.html" class="public">
								<code>getSizeST</code>
							</a>
						</td>
						<td>Returns the edge length in (s,t)-space of cells at the given level.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.IJLevelToBoundUV.html" class="public">
								<code>IJLevelToBoundUV</code>
							</a>
						</td>
						<td>Returns the bound in (u,v)-space for the cell at the given level containing
 the leaf cell with the given (i,j)-coordinates.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.intersects.html" class="public">
								<code>intersects</code>
							</a>
						</td>
						<td>Returns true if the given cell intersects this one.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.isFace.html" class="public">
								<code>isFace</code>
							</a>
						</td>
						<td>Return true if this is a top-level face cell (more efficient than
 checking whether level() == 0).
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.isLeaf.html" class="public">
								<code>isLeaf</code>
							</a>
						</td>
						<td>Returns true if this is a leaf cell (more efficient than checking
 whether level() == MAX_LEVEL).
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.isValid.html" class="public">
								<code>isValid</code>
							</a>
						</td>
						<td>Returns true if id() represents a valid cell.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.level.html" class="public">
								<code>level</code>
							</a>
						</td>
						<td>Returns the subdivision level of the cell (range 0..MAX_LEVEL).
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.lsb.html" class="public">
								<code>lsb</code>
							</a>
						</td>
						<td>Returns the lowest-numbered bit that is on for this cell id, which is
 equal to (uint64(1) &lt;&lt; (2 * (MAX_LEVEL - level))).  So for example,
 a.lsb() &lt;= b.lsb() if and only if a.level() &gt;= b.level(), but the
 first test is more efficient.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.lsbForLevel.html" class="public">
								<code>lsbForLevel</code>
							</a>
						</td>
						<td>Returns the lowest-numbered bit that is on for cells at the given level.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.maximumTile.html" class="public">
								<code>maximumTile</code>
							</a>
						</td>
						<td>Returns the largest cell with the same <code class="lang-d"><span class="pln">range_min</span><span class="pun">()</span></code> and such that
 <code class="lang-d"><span class="pln">range_max</span><span class="pun">() &lt; </span><span class="pln">limit<wbr/></span><span class="pun">.</span><span class="pln">range_min</span><span class="pun">()</span></code>.  Returns "limit" if no such cell exists.
 This method can be used to generate a small set of S2CellIds that covers
 a given range \(a "tiling"\).  This example shows how to generate a tiling
 for a semi-open range of leaf cells [start, limit\):
 <code class="lang-d"></code>`
   for (S2CellId id = start.maximum_tile(limit);
        id != limit; id = id.next().maximum_tile(limit)) { ... }
 <code class="lang-d"></code>`
 Note that in general the cells in the tiling will be of different sizes;
 they gradually get larger \(near the middle of the range\) and then
 gradually get smaller \(as "limit" is approached\).
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.next.html" class="public">
								<code>next</code>
							</a>
						</td>
						<td>Returns the next/previous cell at the same level along the Hilbert curve.
 Works correctly when advancing from one face to the next, but
 does *not* wrap around from the last face to the first or vice versa.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.nextWrap.html" class="public">
								<code>nextWrap</code>
							</a>
						</td>
						<td>Like next() and prev(), but these methods wrap around from the last face
 to the first and vice versa.  They should *not* be used for iteration in
 conjunction with child_begin(), child_end(), Begin(), or End().  The
 input must be a valid cell id.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.none.html" class="public">
								<code>none</code>
							</a>
						</td>
						<td>Returns an representative empty cell smaller than any valid cell..
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.opCmp.html" class="public">
								<code>opCmp</code>
							</a>
						</td>
						<td>Supports &lt;, &lt;=, &gt;, and &gt;= operators.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.opEquals.html" class="public">
								<code>opEquals</code>
							</a>
						</td>
						<td>Supports the == and != operators.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.parent.html" class="public">
								<code>parent</code>
							</a>
						</td>
						<td>Returns the cell at the previous level or at the given level (which must
 be less than or equal to the current level).
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.parent.html" class="public">
								<code>parent</code>
							</a>
						</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.pos.html" class="public">
								<code>pos</code>
							</a>
						</td>
						<td>The position of the cell center along the Hilbert curve over this face,
 in the range 0..(2**POS_BITS-1).
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.prev.html" class="public">
								<code>prev</code>
							</a>
						</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.prevWrap.html" class="public">
								<code>prevWrap</code>
							</a>
						</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.rangeMax.html" class="public">
								<code>rangeMax</code>
							</a>
						</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.rangeMin.html" class="public">
								<code>rangeMin</code>
							</a>
						</td>
						<td>These methods return the range of cell ids that are contained within this
 cell \(including itself\).  The range is *inclusive* \(i.e. test using &gt;=
 and &lt;=\) and the return values of both methods are valid leaf cell ids.
 In other words, <code class="lang-d"><span class="pln">a<wbr/></span><span class="pun">.</span><span class="pln">contains</span><span class="pun">(</span><span class="pln">b</span><span class="pun">)</span></code> if and only if
 <code class="lang-d"></code>`
     (b &gt;= a.range_min() &amp;&amp; b &lt;= a.range_max())
 <code class="lang-d"></code>`
 If you want to iterate through all the descendants of this cell at a
 particular level, use <code class="lang-d"><a href="../../s2/s2cell_id/S2CellId.childBegin.html"><span class="pln">childBegin</span></a><span class="pun">(<a href="../../s2/s2cell_id/S2CellId.level.html"></span><span class="pln">level</span></a><span class="pun">)</span></code> and <code class="lang-d"><a href="../../s2/s2cell_id/S2CellId.childEnd.html"><span class="pln">childEnd</span></a><span class="pun">(<a href="../../s2/s2cell_id/S2CellId.level.html"></span><span class="pln">level</span></a><span class="pun">)</span></code> instead.
 Also see <code class="lang-d"><a href="../../s2/s2cell_id/S2CellId.maximumTile.html"><span class="pln">maximumTile</span></a><span class="pun">()</span></code>, which can be used to iterate through a range of
 cells using S2CellIds at different levels that are as large as possible.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.sentinel.html" class="public">
								<code>sentinel</code>
							</a>
						</td>
						<td>Returns an invalid cell id guaranteed to be larger than any
 valid cell id.  Useful for creating indexes.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.toFaceIJOrientation.html" class="public">
								<code>toFaceIJOrientation</code>
							</a>
						</td>
						<td>Return the (face, i, j) coordinates for the leaf cell corresponding to
 this cell id.  Since cells are represented by the Hilbert curve position
 at the center of the cell, the returned (i,j) for non-leaf cells will be
 a leaf cell adjacent to the cell center.  If "orientation" is non-nullptr,
 also return the Hilbert curve orientation for the current cell.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.toFaceIJOrientation.html" class="public">
								<code>toFaceIJOrientation</code>
							</a>
						</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.toHash.html" class="public">
								<code>toHash</code>
							</a>
						</td>
						<td>The ID serves as a good hash for associative arrays.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.toLatLng.html" class="public">
								<code>toLatLng</code>
							</a>
						</td>
						<td>Returns the S2LatLng corresponding to the center of the given cell.
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.toS2Point.html" class="public">
								<code>toS2Point</code>
							</a>
						</td>
						<td>Returns the direction vector corresponding to the center of the given
 cell.  The vector returned by ToPointRaw is not necessarily unit length.
 This method returns the same result as S2Cell.getCenter().
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.toS2PointRaw.html" class="public">
								<code>toS2PointRaw</code>
							</a>
						</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.toString.html" class="public">
								<code>toString</code>
							</a>
						</td>
						<td>Creates a human readable debug string.  Used for &lt;&lt; and available for
 direct usage as well.  The format is "f/dd..d" where "f" is a digit in
 the range [0-5] representing the S2CellId face, and "dd..d" is a string
 of digits in the range [0-3] representing each child's position with
 respect to its parent.  (Note that the latter string may be empty.)
</td>
					</tr>
					<tr>
						<td>
							<a href="../../s2/s2cell_id/S2CellId.toToken.html" class="public">
								<code>toToken</code>
							</a>
						</td>
						<td>Methods to encode and decode cell ids to compact text strings suitable
 for display or indexing.  Cells at lower levels (i.e. larger cells) are
 encoded into fewer characters.  The maximum token length is 16.
</td>
					</tr>
				</table>
			</section>
			<section><h2>face</h2>
<p>a 3-bit number (range 0..5) encoding the cube face.
</p>
</section>
<section><h2>face pos</h2>
<p>a 61-bit number encoding the position of the center of this
             cell along the Hilbert curve over this face (see the Wiki
             pages for details).
</p>

<p> Sequentially increasing cell ids follow a continuous space-filling curve
 over the entire sphere.  They have the following properties:
</p>

<p>  - The id of a cell at level k consists of a 3-bit face number followed
    by k bit pairs that recursively select one of the four children of
    each cell.  The next bit is always 1, and all other bits are 0.
    Therefore, the level of a cell is determined by the position of its
    lowest-numbered bit that is turned on (for a cell at level k, this
    position is 2 * (MAX_LEVEL - k).)
</p>

<p>  - The id of a parent cell is at the midpoint of the range of ids spanned
    by its children (or by its descendants at any level).
</p>

<p> Leaf cells are often used to represent points on the unit sphere, and
 this class provides methods for converting directly between these two
 representations.  For cells that represent 2D regions rather than
 discrete point, it is better to use the S2Cell class.
</p>

<p> This class is intended to be copied by value as desired.  It uses
 the default copy constructor and assignment operator.
</p>
</section>

			<footer>
				<table class="license-info">
					<tr>
						<th>Authors</th>
						<td>
							
						</td>
					</tr>
					<tr>
						<th>Copyright</th>
						<td>
							
						</td>
					</tr>
					<tr>
						<th>License</th>
						<td>
							
						</td>
					</tr>
				</table>
				<p class="faint">Generated using the DDOX documentation generator</p>
			</footer>
		</div>
	</body>
</html>