
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>s2.s2polygon</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">s2.s2polygon</h1>
        <section id="module_content">
<section class="section ddoc_module_members_section">
  <div class="ddoc_module_members">
    <ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2POLYGON_LAZY_INDEXING" id="S2POLYGON_LAZY_INDEXING"><code class="code">S2POLYGON_LAZY_INDEXING</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2POLYGON_LAZY_INDEXING"></span>enum bool <code class="code">S2POLYGON_LAZY_INDEXING</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Build the S2ShapeIndex only when it is first needed.  This can save
 significant amounts of memory and time when geometry is constructed but
 never queried, for example when converting from one format to another.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon" id="S2Polygon"><code class="code">S2Polygon</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon"></span>class <code class="code">S2Polygon</code>: <span class="ddoc_psuper_symbol">s2.s2region.S2Region</span>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    An <code class="code">S2Polygon</code> is an S2Region object that represents a polygon.  A polygon is
 defined by zero or more loops; recall that the interior of a loop is
 defined to be its left-hand side (see S2Loop).  There are two different
 conventions for creating an <code class="code">S2Polygon</code>:

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
       - InitNested() expects the input loops to be nested hierarchically.  The
     polygon interior then consists of the set of points contained by an odd
     number of loops.  So for example, a circular region with a hole in it
     would be defined as two CCW loops, with one loop containing the other.
     The loops can be provided in any order.
<br><br>
     When the orientation of the input loops is unknown, the nesting
     requirement is typically met by calling S2Loop::Normalize() on each
     loop (which inverts the loop if necessary so that it encloses at most
     half the sphere).  But in fact any set of loops can be used as long as
     (1) there is no pair of loops that cross, and (2) there is no pair of
     loops whose union is the entire sphere.
<br><br>
   - InitOriented() expects the input loops to be oriented such that the
     polygon interior is on the left-hand side of every loop.  So for
     example, a circular region with a hole in it would be defined using a
     CCW outer loop and a CW inner loop.  The loop orientations must all be
     consistent; for example, it is not valid to have one CCW loop nested
     inside another CCW loop, because the region between the two loops is on
     the left-hand side of one loop and the right-hand side of the other.
<br><br>
 Most clients will not call these methods directly; instead they should use
 S2Builder, which has better support for dealing with imperfect data.
<br><br>
 When the polygon is initialized, the given loops are automatically
 converted into a canonical form consisting of "shells" and "holes".  Shells
 and holes are both oriented CCW, and are nested hierarchically.  The loops
 are reordered to correspond to a preorder traversal of the nesting
 hierarchy; InitOriented may also invert some loops. The set of input S2Loop
 pointers is always preserved; the caller can use this to determine how the
 loops were reordered if desired.
<br><br>
 Polygons may represent any region of the sphere with a polygonal boundary,
 including the entire sphere (known as the "full" polygon).  The full
 polygon consists of a single full loop (see S2Loop), whereas the empty
 polygon has no loops at all.
<br><br>
 Polygons have the following restrictions:
<br><br>
  - Loops may not cross, i.e. the boundary of a loop may not intersect
    both the interior and exterior of any other loop.
<br><br>
  - Loops may not share edges, i.e. if a loop contains an edge AB, then
    no other loop may contain AB or BA.
<br><br>
  - Loops may share vertices, however no vertex may appear twice in a
    single loop (see S2Loop).
<br><br>
  - No loop may be empty.  The full loop may appear only in the full polygon.
  </p>
</div>

</section>
<ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.this" id="S2Polygon.this"><code class="code">this</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.this"></span>this();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    The default constructor creates an empty polygon.  It can be made
 non-empty by calling Init(), Decode(), etc.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.this" id="S2Polygon.this"><code class="code">this</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.this.2"></span>this(S2Loop[] <code class="code">loops</code>, S2Debug <code class="code">s2debugOverride</code> = S2Debug.ALLOW);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Convenience constructor that calls InitNested() with the given <code class="code">loops</code>.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    When called with override == S2Debug::ALLOW, the automatic validity
 checking is controlled by --s2debug (which is <code class="code">true</code> by default in
 non-optimized builds).  When this flag is enabled, a fatal error is
 generated whenever an invalid polygon is constructed.
<br><br>
 With override == S2Debug::DISABLE, the automatic validity checking
 is disabled.  The main reason to do this is if you intend to call
 IsValid() explicitly.  (See set_s2debug_override() for details.)

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">Example:</span>
S2Polygon* polygon = new S2Polygon(<code class="code">loops</code>, S2Debug::DISABLE);
<br><br>
 This is equivalent to:
<br><br>
   S2Polygon* polygon = new S2Polygon;
   polygon-&gt;set_s2debug_override(S2Debug::DISABLE);
   polygon-&gt;InitNested(<code class="code">loops</code>);
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.this" id="S2Polygon.this"><code class="code">this</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.this.3"></span>this(in S2Cell <code class="code">cell</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Convenience constructor that creates a polygon with a single loop
 corresponding to the given <code class="code">cell</code>.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.this" id="S2Polygon.this"><code class="code">this</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.this.4"></span>this(S2Loop <code class="code">loop</code>, S2Debug <code class="code">s2debugOverride</code> = S2Debug.ALLOW);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Convenience constructor that calls Init(S2Loop*).  Note that this method
 automatically converts the special empty <code class="code">loop</code> (see S2Loop) into an empty
 polygon, unlike the vector-of-loops constructor which does not allow
 empty loops at all.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.initializeNested" id="S2Polygon.initializeNested"><code class="code">initializeNested</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.initializeNested"></span>void <code class="code">initializeNested</code>(S2Loop[] <code class="code">loops</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Create a polygon from a set of hierarchically nested <code class="code">loops</code>.  The polygon
 interior consists of the points contained by an odd number of <code class="code">loops</code>.
 (Recall that a loop contains the set of points on its left-hand side.)

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    This method figures out the loop nesting hierarchy and assigns every
 loop a depth.  Shells have even depths, and holes have odd depths.  Note
 that the <code class="code">loops</code> are reordered so the hierarchy can be traversed more
 easily (see GetParent(), GetLastDescendant(), and S2Loop::depth()).
<br><br>
 This method may be called more than once, in which case any existing
 <code class="code">loops</code> are deleted before being replaced by the input <code class="code">loops</code>.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.initializeOriented" id="S2Polygon.initializeOriented"><code class="code">initializeOriented</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.initializeOriented"></span>void <code class="code">initializeOriented</code>(S2Loop[] <code class="code">loops</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Like InitNested(), but expects <code class="code">loops</code> to be oriented such that the polygon
 interior is on the left-hand side of all <code class="code">loops</code>.  This implies that shells
 and holes should have opposite orientations in the input to this method.
 (During initialization, <code class="code">loops</code> representing holes will automatically be
 inverted.)
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.initialize" id="S2Polygon.initialize"><code class="code">initialize</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.initialize"></span>void <code class="code">initialize</code>(S2Loop <code class="code">loop</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Initialize a polygon from a single <code class="code">loop</code>.  Note that this method
 automatically converts the special empty <code class="code">loop</code> (see S2Loop) into an empty
 polygon, unlike the vector-of-loops InitNested() method which does not
 allow empty loops at all.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.release" id="S2Polygon.release"><code class="code">release</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.release"></span>S2Loop[] <code class="code">release</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Releases ownership of and returns the loops of this polygon, and resets
 the polygon to be empty.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.setS2debugOverride" id="S2Polygon.setS2debugOverride"><code class="code">setS2debugOverride</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.setS2debugOverride"></span>void <code class="code">setS2debugOverride</code>(S2Debug <code class="code">s2debugOverride</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Destroys the polygon and frees its loops.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Allows overriding the automatic validity checks controlled by
 --s2debug (which is <code class="code">true</code> by default in non-optimized builds).
 When this flag is enabled, a fatal error is generated whenever
 an invalid polygon is constructed.  The main reason to disable
 this flag is if you intend to call IsValid() explicitly, like this:
<br><br>
   S2Polygon polygon;
   polygon.set_s2debug_override(S2Debug::DISABLE);
   polygon.Init(...);
   if (!polygon.IsValid()) { ... }
<br><br>
 This setting is preserved across calls to Init() and Decode().
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.isValid" id="S2Polygon.isValid"><code class="code">isValid</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.isValid"></span>bool <code class="code">isValid</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns <code class="code">true</code> if this is a valid polygon (including checking whether all
 the loops are themselves valid).  Note that validity is checked
 automatically during initialization when --s2debug is enabled (<code class="code">true</code> by
 default in debug binaries).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.findValidationError" id="S2Polygon.findValidationError"><code class="code">findValidationError</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.findValidationError"></span>bool <code class="code">findValidationError</code>(out S2Error <code class="code">error</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns <code class="code">true</code> if this is *not* a valid polygon and sets "<code class="code">error</code>"
 appropriately.  Otherwise returns <code class="code">false</code> and leaves "<code class="code">error</code>" unchanged.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Note that in <code class="code">error</code> messages, loops that represent holes have their edges
 numbered in reverse order, starting from the last vertex of the loop.


  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">REQUIRES:</span>
<code class="code">error</code> != nullptr
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.isEmpty" id="S2Polygon.isEmpty"><code class="code">isEmpty</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.isEmpty"></span>const bool <code class="code">isEmpty</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return <code class="code">true</code> if this is the empty polygon (consisting of no loops).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.isFull" id="S2Polygon.isFull"><code class="code">isFull</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.isFull"></span>const bool <code class="code">isFull</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return <code class="code">true</code> if this is the full polygon (consisting of a single loop that
 encompasses the entire sphere).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.numLoops" id="S2Polygon.numLoops"><code class="code">numLoops</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.numLoops"></span>const int <code class="code">numLoops</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return the number of loops in this polygon.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.numVertices" id="S2Polygon.numVertices"><code class="code">numVertices</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.numVertices"></span>const int <code class="code">numVertices</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Total number of vertices in all loops.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.getParent" id="S2Polygon.getParent"><code class="code">getParent</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.getParent"></span>const int <code class="code">getParent</code>(int <code class="code">k</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return the index of the parent of loop <code class="code">k</code>, or -1 if it has no parent.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.getLastDescendant" id="S2Polygon.getLastDescendant"><code class="code">getLastDescendant</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.getLastDescendant"></span>const int <code class="code">getLastDescendant</code>(int <code class="code">k</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return the index of the last loop that is contained within loop <code class="code">k</code>.
 Returns num_loops() - 1 if <code class="code">k</code> &lt; 0.  Note that loops are indexed according
 to a preorder traversal of the nesting hierarchy, so the immediate
 children of loop <code class="code">k</code> can be found by iterating over loops
 (<code class="code">k</code>+1)..GetLastDescendant(<code class="code">k</code>) and selecting those whose depth is equal to
 (loop(<code class="code">k</code>)-&gt;depth() + 1).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.getArea" id="S2Polygon.getArea"><code class="code">getArea</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.getArea"></span>const double <code class="code">getArea</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return the area of the polygon interior, i.e. the region on the left side
 of an odd number of loops.  The return value is between 0 and 4*Pi.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.getCentroid" id="S2Polygon.getCentroid"><code class="code">getCentroid</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.getCentroid"></span>const S2Point <code class="code">getCentroid</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return the <code class="code">true</code> centroid of the polygon multiplied by the area of the
 polygon (see s2centroids.h for details on centroids).  The result is not
 unit length, so you may want to normalize it.  Also note that in general,
 the centroid may not be contained by the polygon.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    We prescale by the polygon area for two reasons: (1) it is cheaper to
 compute this way, and (2) it makes it easier to compute the centroid of
 more complicated shapes (by splitting them into disjoint regions and
 adding their centroids).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.getSnapLevel" id="S2Polygon.getSnapLevel"><code class="code">getSnapLevel</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.getSnapLevel"></span>const int <code class="code">getSnapLevel</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    If all of the polygon's vertices happen to be the centers of S2Cells at
 some level, then return that level, otherwise return -1.  See also
 InitToSnapped() and s2builderutil::S2CellIdSnapFunction.
 Returns -1 if the polygon has no vertices.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.getDistance" id="S2Polygon.getDistance"><code class="code">getDistance</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.getDistance"></span>S1Angle <code class="code">getDistance</code>(in S2Point <code class="code">x</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return the distance from the given point to the polygon interior.  If the
 polygon is empty, return S1Angle::Infinity().  "<code class="code">x</code>" should be unit length.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.getDistanceToBoundary" id="S2Polygon.getDistanceToBoundary"><code class="code">getDistanceToBoundary</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.getDistanceToBoundary"></span>S1Angle <code class="code">getDistanceToBoundary</code>(in S2Point <code class="code">x</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return the distance from the given point to the polygon boundary.  If the
 polygon is empty or full, return S1Angle::Infinity() (since the polygon
 has no boundary).  "<code class="code">x</code>" should be unit length.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.getOverlapFractions" id="S2Polygon.getOverlapFractions"><code class="code">getOverlapFractions</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.getOverlapFractions"></span>static OverlapFractions <code class="code">getOverlapFractions</code>(S2Polygon <code class="code">a</code>, S2Polygon <code class="code">b</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return the overlap fractions between two polygons, i.e. the ratios of the
 area of intersection to the area of each polygon.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.project" id="S2Polygon.project"><code class="code">project</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.project"></span>S2Point <code class="code">project</code>(in S2Point <code class="code">x</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    If the given point is contained by the polygon, return it.  Otherwise
 return the closest point on the polygon boundary.  If the polygon is
 empty, return the input argument.  Note that the result may or may not be
 contained by the polygon.  "<code class="code">x</code>" should be unit length.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.projectToBoundary" id="S2Polygon.projectToBoundary"><code class="code">projectToBoundary</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.projectToBoundary"></span>S2Point <code class="code">projectToBoundary</code>(in S2Point <code class="code">x</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return the closest point on the polygon boundary to the given point.  If
 the polygon is empty or full, return the input argument (since the
 polygon has no boundary).  "<code class="code">x</code>" should be unit length.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.contains" id="S2Polygon.contains"><code class="code">contains</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.contains"></span>bool <code class="code">contains</code>(S2Polygon <code class="code">b</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return <code class="code">true</code> if this polygon <code class="code">contains</code> the given other polygon, i.e.
 if polygon A <code class="code">contains</code> all points contained by polygon B.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.approxContains" id="S2Polygon.approxContains"><code class="code">approxContains</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.approxContains"></span>bool <code class="code">approxContains</code>(S2Polygon <code class="code">b</code>, S1Angle <code class="code">tolerance</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns <code class="code">true</code> if this polgyon (A) approximately contains the given other
 polygon (B). This is <code class="code">true</code> if it is possible to move the vertices of B
 no further than "<code class="code">tolerance</code>" such that A contains the modified B.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    For example, the empty polygon will contain any polygon whose maximum
 width is no more than "<code class="code">tolerance</code>".
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.intersects" id="S2Polygon.intersects"><code class="code">intersects</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.intersects"></span>bool <code class="code">intersects</code>(S2Polygon <code class="code">b</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return <code class="code">true</code> if this polygon <code class="code">intersects</code> the given other polygon, i.e.
 if there is a point that is contained by both polygons.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.approxDisjoint" id="S2Polygon.approxDisjoint"><code class="code">approxDisjoint</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.approxDisjoint"></span>bool <code class="code">approxDisjoint</code>(S2Polygon <code class="code">b</code>, S1Angle <code class="code">tolerance</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns <code class="code">true</code> if this polgyon (A) and the given polygon (B) are
 approximately disjoint.  This is <code class="code">true</code> if it is possible to ensure that A
 and B do not intersect by moving their vertices no further than
 "<code class="code">tolerance</code>".  This implies that in borderline cases where A and B overlap
 slightly, this method returns <code class="code">true</code> (A and B are approximately disjoint).

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    For example, any polygon is approximately disjoint from a polygon whose
 maximum width is no more than "<code class="code">tolerance</code>".
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.initializeToIntersection" id="S2Polygon.initializeToIntersection"><code class="code">initializeToIntersection</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.initializeToIntersection"></span>void <code class="code">initializeToIntersection</code>(S2Polygon <code class="code">a</code>, S2Polygon <code class="code">b</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Initialize this polygon to the intersection, union, difference (A - B),
 or symmetric difference (XOR) of the given two polygons.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    "snap_function" allows you to specify <code class="code">a</code> minimum spacing between output
 vertices, and/or that the vertices should be snapped to <code class="code">a</code> discrete set of
 points (e.g. S2CellId centers or E7 lat/lng coordinates).  Any snap
 function can be used, including the IdentitySnapFunction with <code class="code">a</code>
 snap_radius of zero (which preserves the input vertices exactly).
<br><br>
 The boundary of the output polygon before snapping is guaranteed to be
 accurate to within S2::kIntersectionError of the exact result.
 Snapping can move the boundary by an additional distance that depends on
 the snap function.  Finally, any degenerate portions of the output
 polygon are automatically removed (i.e., regions that do not contain any
 points) since S2Polygon does not allow such regions.
<br><br>
 See S2Builder and s2builderutil for more details on snap functions.  For
 example, you can snap to E7 coordinates by setting "snap_function" to
 s2builderutil::IntLatLngSnapFunction(7).
<br><br>
 The default snap function is the IdentitySnapFunction with <code class="code">a</code> snap radius
 of S2::kIntersectionMergeRadius (equal to about 1.8e-15 radians
 or 11 nanometers on the Earth's surface).  This means that vertices may
 be positioned arbitrarily, but vertices that are extremely close together
 can be merged together.  The reason for <code class="code">a</code> non-zero default snap radius is
 that it helps to eliminate narrow cracks and slivers when T-vertices are
 present.  For example, adjacent S2Cells at different levels do not share
 exactly the same boundary, so there can be <code class="code">a</code> narrow crack between them.
 If <code class="code">a</code> polygon is intersected with those cells and the pieces are unioned
 together, the result would have <code class="code">a</code> narrow crack unless the snap radius is
 set to <code class="code">a</code> non-zero value.
<br><br>
 Note that if you want to encode the vertices in <code class="code">a</code> lower-precision
 representation (such as S2CellIds or E7), it is much better to use <code class="code">a</code>
 suitable SnapFunction rather than rounding the vertices yourself, because
 this will create self-intersections unless you ensure that the vertices
 and edges are sufficiently well-separated first.  In particular you need
 to use <code class="code">a</code> snap function whose min_edge_vertex_separation() is at least
 twice the maximum distance that <code class="code">a</code> vertex can move when rounded.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.initializeToSnapped" id="S2Polygon.initializeToSnapped"><code class="code">initializeToSnapped</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.initializeToSnapped"></span>void <code class="code">initializeToSnapped</code>(in S2Polygon <code class="code">a</code>, in S2Builder.SnapFunction <code class="code">snap_function</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Snaps the vertices of the given polygon using the given SnapFunction
 (e.g., s2builderutil::IntLatLngSnapFunction(6) snaps to E6 coordinates).
 This can change the polygon topology (merging loops, for example), but
 the resulting polygon is guaranteed to be valid, and no vertex will move
 by more than <code class="code">snap_function</code>.snap_radius().  See S2Builder for other
 guarantees (e.g., minimum edge-vertex separation).

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Note that this method is <code class="code">a</code> thin wrapper over S2Builder, so if you are
 starting with data that is not in S2Polygon format (e.g., integer E7
 coordinates) then it is faster to just use S2Builder directly.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.initializeToSnapped" id="S2Polygon.initializeToSnapped"><code class="code">initializeToSnapped</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.initializeToSnapped.2"></span>void <code class="code">initializeToSnapped</code>(in S2Polygon <code class="code">a</code>, int <code class="code">snap_level</code> = S2CellId.MAX_LEVEL);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Convenience function that snaps the vertices to S2CellId centers at the
 given level (default level 30, which has S2CellId centers spaced about 1
 centimeter apart).  Polygons can be efficiently encoded by Encode() after
 they have been snapped.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.initializeToSimplified" id="S2Polygon.initializeToSimplified"><code class="code">initializeToSimplified</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.initializeToSimplified"></span>void <code class="code">initializeToSimplified</code>(in S2Polygon <code class="code">a</code>, S2Builder.SnapFunction <code class="code">snap_function</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Snaps the input polygon according to the given "<code class="code">snap_function</code>" and
 reduces the number of vertices if possible, while ensuring that no vertex
 moves further than <code class="code">snap_function</code>.snap_radius().

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Simplification works by replacing nearly straight chains of short edges
 with longer edges, in <code class="code">a</code> way that preserves the topology of the input
 polygon up to the creation of degeneracies.  This means that loops or
 portions of loops may become degenerate, in which case they are removed.
 For example, if there is <code class="code">a</code> very small island in the original polygon, it
 may disappear completely.  (Even if there are dense islands, they could
 all be removed rather than being replaced by <code class="code">a</code> larger simplified island
 if more area is covered by water than land.)
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.initializeToSimplifiedInCell" id="S2Polygon.initializeToSimplifiedInCell"><code class="code">initializeToSimplifiedInCell</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.initializeToSimplifiedInCell"></span>void <code class="code">initializeToSimplifiedInCell</code>(in S2Polygon <code class="code">a</code>, in S2Cell <code class="code">cell</code>, S1Angle <code class="code">snap_radius</code>, S1Angle <code class="code">boundary_tolerance</code> = S1Angle.fromRadians(1e-15));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Like InitToSimplified, except that any vertices or edges on the boundary
 of the given S2Cell are preserved if possible.  This method requires that
 the polygon has already been clipped so that it does not extend outside
 the <code class="code">cell</code> by more than "<code class="code">boundary_tolerance</code>".  In other words, it operates
 on polygons that have already been intersected with <code class="code">a</code> <code class="code">cell</code>.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Typically this method is used in geometry-processing pipelines that
 intersect polygons with <code class="code">a</code> collection of S2Cells and then process those
 cells in parallel, where each <code class="code">cell</code> generates some geometry that needs to
 be simplified.  In contrast, if you just need to simplify the *input*
 geometry then it is easier and faster to do the simplification before
 computing the intersection with any S2Cells.
<br><br>
 "<code class="code">boundary_tolerance</code>" specifies how close <code class="code">a</code> vertex must be to the <code class="code">cell</code>
 boundary to be kept.  The default tolerance is large enough to handle any
 reasonable way of interpolating points along the <code class="code">cell</code> boundary, such as
 S2::GetIntersection(), S2::Interpolate(), or direct (u,v)
 interpolation using S2::FaceUVtoXYZ().  However, if the vertices have
 been snapped to <code class="code">a</code> lower-precision representation (e.g., S2CellId centers
 or E7 coordinates) then you will need to set this tolerance explicitly.
 For example, if the vertices were snapped to E7 coordinates then
 "<code class="code">boundary_tolerance</code>" should be set to
<br><br>
   s2builderutil::IntLatLngSnapFunction::MinSnapRadiusForExponent(7)
<br><br>
 Degenerate portions of loops are always removed, so if <code class="code">a</code> vertex on the
 <code class="code">cell</code> boundary belongs only to degenerate regions then it will not be
 kept.  For example, if the input polygon is <code class="code">a</code> narrow strip of width less
 than "<code class="code">snap_radius</code>" along one side of the <code class="code">cell</code>, then the entire loop may
 become degenerate and be removed.


  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">REQUIRES:</span>
all vertices of "<code class="code">a</code>" are within "<code class="code">boundary_tolerance</code>" of "<code class="code">cell</code>".
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.initializeToComplement" id="S2Polygon.initializeToComplement"><code class="code">initializeToComplement</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.initializeToComplement"></span>void <code class="code">initializeToComplement</code>(in S2Polygon <code class="code">a</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Initialize this polygon to the complement of the given polygon.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.invert" id="S2Polygon.invert"><code class="code">invert</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.invert"></span>void <code class="code">invert</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Invert the polygon (replace it by its complement).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.contains" id="S2Polygon.contains"><code class="code">contains</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.contains.2"></span>bool <code class="code">contains</code>(in S2Polyline <code class="code">b</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return <code class="code">true</code> if this polygon <code class="code">contains</code> the given polyline.  This method
 returns an exact result, according to the following model:

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
      - All edges are geodesics (of course).
<br><br>
  - Vertices are ignored for the purposes of defining containment.
    (This is because polygons often do not contain their vertices, in
    order to that when a set of polygons tiles the sphere then every point
    is contained by exactly one polygon.)
<br><br>
  - Points that lie exactly on geodesic edges are resolved using symbolic
    perturbations (i.e., they are considered to be infinitesmally offset
    from the edge).
<br><br>
  - If the polygon and polyline share an edge, it is handled as follows.
    First, the polygon edges are oriented so that the interior is always
    on the left.  Then the shared polyline edge is contained if and only
    if it is in the same direction as the corresponding polygon edge.
    (This model ensures that when a polyline is intersected with a polygon
    and its complement, the edge only appears in one of the two results.)
<br><br>
 TODO(ericv): Update the implementation to correspond to the model above.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.approxContains" id="S2Polygon.approxContains"><code class="code">approxContains</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.approxContains.2"></span>bool <code class="code">approxContains</code>(in S2Polyline <code class="code">b</code>, S1Angle <code class="code">tolerance</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns <code class="code">true</code> if this polgyon approximately contains the given polyline
 This is <code class="code">true</code> if it is possible to move the polyline vertices no further
 than "<code class="code">tolerance</code>" such that the polyline is now contained.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.intersects" id="S2Polygon.intersects"><code class="code">intersects</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.intersects.2"></span>bool <code class="code">intersects</code>(in S2Polyline <code class="code">b</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return <code class="code">true</code> if this polygon <code class="code">intersects</code> the given polyline.  This method
 returns an exact result; see Contains(S2Polyline) for details.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.approxDisjoint" id="S2Polygon.approxDisjoint"><code class="code">approxDisjoint</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.approxDisjoint.2"></span>bool <code class="code">approxDisjoint</code>(const S2Polyline <code class="code">b</code>, S1Angle <code class="code">tolerance</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns <code class="code">true</code> if this polgyon is approximately disjoint from the given
 polyline.  This is <code class="code">true</code> if it is possible to avoid intersection by moving
 their vertices no further than "<code class="code">tolerance</code>".

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    This implies that in borderline cases where there is a small overlap,
 this method returns <code class="code">true</code> (i.e., they are approximately disjoint).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.intersectWithPolyline" id="S2Polygon.intersectWithPolyline"><code class="code">intersectWithPolyline</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.intersectWithPolyline"></span>S2Polyline[] <code class="code">intersectWithPolyline</code>(in S2Polyline <code class="code">a</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Intersect this polygon with the polyline "in" and return the resulting
 zero or more polylines.  The polylines are returned in the order they
 would be encountered by traversing "in" from beginning to end.
 Note that the output may include polylines with only one vertex,
 but there will not be any zero-vertex polylines.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    This is equivalent to calling ApproxIntersectWithPolyline() with the
 "snap_radius" set to S2::kIntersectionMergeRadius.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.approxIntersectWithPolyline" id="S2Polygon.approxIntersectWithPolyline"><code class="code">approxIntersectWithPolyline</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.approxIntersectWithPolyline"></span>S2Polyline[] <code class="code">approxIntersectWithPolyline</code>(in S2Polyline <code class="code">a</code>, S1Angle <code class="code">snap_radius</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Similar to IntersectWithPolyline(), except that vertices will be
 dropped as necessary to ensure that all adjacent vertices in the
 sequence obtained by concatenating the output polylines will be
 farther than "<code class="code">snap_radius</code>" apart.  Note that this can change
 the number of output polylines and/or yield single-vertex polylines.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.subtractFromPolyline" id="S2Polygon.subtractFromPolyline"><code class="code">subtractFromPolyline</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.subtractFromPolyline"></span>S2Polyline[] <code class="code">subtractFromPolyline</code>(in S2Polyline <code class="code">a</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Same as IntersectWithPolyline, but subtracts this polygon from
 the given polyline.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.approxSubtractFromPolyline" id="S2Polygon.approxSubtractFromPolyline"><code class="code">approxSubtractFromPolyline</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.approxSubtractFromPolyline"></span>S2Polyline[] <code class="code">approxSubtractFromPolyline</code>(in S2Polyline <code class="code">a</code>, S1Angle <code class="code">snap_radius</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Same as ApproxIntersectWithPolyline, but subtracts this polygon
 from the given polyline.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.destructiveUnion" id="S2Polygon.destructiveUnion"><code class="code">destructiveUnion</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.destructiveUnion"></span>static S2Polygon <code class="code">destructiveUnion</code>(S2Polygon[] <code class="code">polygons</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return a polygon which is the union of the given <code class="code">polygons</code>.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.initializeToCellUnionBorder" id="S2Polygon.initializeToCellUnionBorder"><code class="code">initializeToCellUnionBorder</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.initializeToCellUnionBorder"></span>void <code class="code">initializeToCellUnionBorder</code>(in S2CellUnion <code class="code">cells</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Initialize this polygon to the outline of the given cell union.
 In principle this polygon should exactly contain the cell union and
 this polygon's inverse should not intersect the cell union, but rounding
 issues may cause this not to be the case.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.isNormalized" id="S2Polygon.isNormalized"><code class="code">isNormalized</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.isNormalized"></span>const bool <code class="code">isNormalized</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return <code class="code">true</code> if every loop of this polygon shares at most one vertex with
 its parent loop.  Every polygon has a unique normalized form.  A polygon
 can be normalized by passing it through S2Builder (with no snapping) in
 order to reconstruct the polygon from its edges.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Generally there is no reason to convert polygons to normalized form.  It
 is mainly useful for testing in order to compare whether two polygons
 have exactly the same interior, even when they have a different loop
 structure.  For example, a diamond nested within a square (touching at
 four points) could be represented as a square with a diamond-shaped hole,
 or as four triangles.  Methods such as BoundaryApproxEquals() will report
 these polygons as being different (because they have different
 boundaries) even though they contain the same points.  However if they
 are both converted to normalized form (the "four triangles" version) then
 they can be compared more easily.
<br><br>
 Also see ApproxEquals(), which can determine whether two polygons contain
 approximately the same set of points without any need for normalization.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.opEquals" id="S2Polygon.opEquals"><code class="code">opEquals</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.opEquals"></span>const bool <code class="code">opEquals</code>(in Object <code class="code">o</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return <code class="code">true</code> if two polygons have exactly the same loops.  The loops must
 appear in the same order, and corresponding loops must have the same
 linear vertex ordering (i.e., cyclic rotations are not allowed).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.approxEquals" id="S2Polygon.approxEquals"><code class="code">approxEquals</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.approxEquals"></span>bool <code class="code">approxEquals</code>(S2Polygon <code class="code">b</code>, S1Angle <code class="code">tolerance</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return <code class="code">true</code> if two polygons are approximately equal to within the given
 <code class="code">tolerance</code>.  This is <code class="code">true</code> if it is possible to move the vertices of the
 two polygons so that they contain the same set of points.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Note that according to this model, small regions less than "<code class="code">tolerance</code>" in
 width do not need to be considered, since these regions can be collapsed
 into degenerate loops (which contain no points) by moving their vertices.
<br><br>
 This model is not as strict as using the Hausdorff distance would be, and
 it is also not as strict as BoundaryNear (defined below).  However, it is
 a good choice for comparing polygons that have been snapped, simplified,
 unioned, etc, since these operations use a model similar to this one
 (i.e., degenerate loops or portions of loops are automatically removed).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.boundaryEquals" id="S2Polygon.boundaryEquals"><code class="code">boundaryEquals</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.boundaryEquals"></span>const bool <code class="code">boundaryEquals</code>(in S2Polygon <code class="code">b</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns <code class="code">true</code> if two polygons have the same boundary.  More precisely,
 this method requires that both polygons have loops with the same cyclic
 vertex order and the same nesting hierarchy.  (This implies that vertices
 may be cyclically rotated between corresponding loops, and the loop
 ordering may be different between the two polygons as long as the nesting
 hierarchy is the same.)
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.boundaryApproxEquals" id="S2Polygon.boundaryApproxEquals"><code class="code">boundaryApproxEquals</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.boundaryApproxEquals"></span>const bool <code class="code">boundaryApproxEquals</code>(in S2Polygon <code class="code">b</code>, S1Angle <code class="code">max_error</code> = S1Angle.fromRadians(1e-15));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return <code class="code">true</code> if two polygons have the same boundary except for vertex
 perturbations.  Both polygons must have loops with the same cyclic vertex
 order and the same nesting hierarchy, but the vertex locations are
 allowed to differ by up to "<code class="code">max_error</code>".
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.boundaryNear" id="S2Polygon.boundaryNear"><code class="code">boundaryNear</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.boundaryNear"></span>const bool <code class="code">boundaryNear</code>(in S2Polygon <code class="code">b</code>, S1Angle <code class="code">max_error</code> = S1Angle.fromRadians(1e-15));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Return <code class="code">true</code> if two polygons have boundaries that are within "<code class="code">max_error</code>"
 of each other along their entire lengths.  More precisely, there must be
 a bijection between the two sets of loops such that for each pair of
 loops, "a_loop-&gt;BoundaryNear(b_loop)" is <code class="code">true</code>.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.spaceUsed" id="S2Polygon.spaceUsed"><code class="code">spaceUsed</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.spaceUsed"></span>const size_t <code class="code">spaceUsed</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the total number of bytes used by the polygon.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.clone" id="S2Polygon.clone"><code class="code">clone</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.clone"></span>const S2Polygon <code class="code">clone</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    GetRectBound() returns essentially tight results, while GetCapBound()
 might have a lot of extra padding.  Both bounds are conservative in that
 if the loop contains a point P, then the bound contains P also.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.getCapBound" id="S2Polygon.getCapBound"><code class="code">getCapBound</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.getCapBound"></span>const S2Cap <code class="code">getCapBound</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Cap surrounding rect bound.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.contains" id="S2Polygon.contains"><code class="code">contains</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.contains.3"></span>bool <code class="code">contains</code>(in S2Point <code class="code">p</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    The point '<code class="code">p</code>' does not need to be normalized.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.encode" id="S2Polygon.encode"><code class="code">encode</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.encode"></span>const void <code class="code">encode</code>(ORangeT)(Encoder!ORangeT <code class="code">encoder</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Appends a serialized representation of the S2Polygon to "<code class="code">encoder</code>".

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    The encoding uses about 4 bytes per vertex for typical polygons in
 Google's geographic repository, assuming that most vertices have been
 snapped to the centers of S2Cells at some fixed level (typically using
 InitToSnapped). The remaining vertices are stored using 24 bytes.
 Decoding a polygon encoded this way always returns the original polygon,
 without any loss of precision.
<br><br>
 The snap level is chosen to be the one that has the most vertices snapped
 to S2Cells at that level.  If most vertices need 24 bytes, then all
 vertices are encoded this way (this method automatically chooses the
 encoding that has the best chance of giving the smaller output size).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.decode" id="S2Polygon.decode"><code class="code">decode</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.decode"></span>bool <code class="code">decode</code>(IRangeT)(Decoder!IRangeT <code class="code">decoder</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Decodes a polygon encoded with Encode().  Returns <code class="code">true</code> on success.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.Shape" id="S2Polygon.Shape"><code class="code">Shape</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.Shape"></span>class <code class="code">Shape</code>: <span class="ddoc_psuper_symbol">s2.s2shape.S2Shape</span>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Wrapper class for indexing a polygon (see S2ShapeIndex).  Once this
 object is inserted into an S2ShapeIndex it is owned by that index, and
 will be automatically deleted when no longer needed by the index.  Note
 that this class does not take ownership of the polygon itself (see
 OwningShape below).  You can also subtype this class to store additional
 data (see S2Shape for details).

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Note that unlike S2Polygon, the edges of S2Polygon::<code class="code">Shape</code> are directed
 such that the polygon interior is always on the left.
  </p>
</div>

</section>
<ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.Shape.this" id="S2Polygon.Shape.this"><code class="code">this</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.Shape.this"></span>this(in S2Polygon <code class="code">polygon</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Initialization.  Does not take ownership of "<code class="code">polygon</code>".  May be called
 more than once.
 TODO(ericv/jrosenstock): Make "<code class="code">polygon</code>" a const reference.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.Shape.numEdges" id="S2Polygon.Shape.numEdges"><code class="code">numEdges</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.Shape.numEdges"></span>final const int <code class="code">numEdges</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    S2Shape interface:
  </p>
</div>

</section>

</div>

</li>
</ul>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2Polygon.index" id="S2Polygon.index"><code class="code">index</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2Polygon.index"></span>MutableS2ShapeIndex <code class="code">index</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the built-in S2ShapeIndex associated with every S2Polygon.  This
 can be used in conjunction with the various S2ShapeIndex query classes
 (S2ClosestEdgeQuery, S2BooleanOperation, etc) to do things beyond what is
 possible with S2Polygon built-in convenience methods.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    For example, to measure the distance from one S2Polygon to another, you
 can write:
   S2ClosestEdgeQuery query(&polygon1.<code class="code">index</code>());
   S2ClosestEdgeQuery::ShapeIndexTarget target(&polygon2.<code class="code">index</code>());
   S1ChordAngle distance = query.GetDistance(&target);
<br><br>
 The <code class="code">index</code> contains a single S2Polygon::Shape object.
  </p>
</div>

</section>

</div>

</li>
</ul>

</div>

</li>
</ul>
  </div>
</section>
</section>
      </article>
    </div>
  </body>
</html>
