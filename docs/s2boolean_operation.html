
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>s2.s2boolean_operation</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">s2.s2boolean_operation</h1>
        <section id="module_content">
<section class="section ddoc_module_members_section">
  <div class="ddoc_module_members">
    <ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2BooleanOperation" id="S2BooleanOperation"><code class="code">S2BooleanOperation</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2BooleanOperation"></span>class <code class="code">S2BooleanOperation</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    This class implements boolean operations (intersection, union, difference,
 and symmetric difference) for regions whose boundaries are defined by
 geodesic edges.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    <code class="code">S2BooleanOperation</code> operates on exactly two input regions at a time.  Each
 region is represented as an S2ShapeIndex and may contain any number of
 points, polylines, and polygons.  The region is essentially the union of
 these objects, except that polygon interiors must be disjoint from all
 other geometry (including other polygon interiors).  If the input geometry
 for a region does not meet this condition, it can be normalized by
 computing its union first.  Note that points or polylines are allowed to
 coincide with the boundaries of polygons.
<br><br>
 Degeneracies are supported.  A polygon loop or polyline may consist of a
 single edge from a vertex to itself, and polygons may contain "sibling
 pairs" consisting of an edge and its corresponding reverse edge.  Polygons
 must not have any duplicate edges (due to the requirement that polygon
 interiors are disjoint), but polylines may have duplicate edges or can even
 be self-intersecting.
<br><br>
 Points and polyline edges are treated as multisets: if the same point or
 polyline edge appears multiple times in the input, it will appear multiple
 times in the output.  For example, the union of a point with an identical
 point consists of two points.  This feature is useful for modeling large
 sets of points or polylines as a single region while maintaining their
 distinct identities, even when the points or polylines intersect each
 other.  It is also useful for reconstructing polylines that loop back on
 themselves.  If duplicate geometry is not desired, it can be merged by
 GraphOptions::DuplicateEdges::MERGE in the S2Builder output layer.
<br><br>
 Polylines are always considered to be directed.  Polyline edges between the
 same pair of vertices are defined to intersect even if the two edges are in
 opposite directions.  (Undirected polylines can be modeled by specifying
 GraphOptions::EdgeType::UNDIRECTED in the S2Builder output layer.)
<br><br>
 The output of each operation is sent to an S2Builder::Layer provided by the
 client.  This allows clients to build any representation of the geometry
 they choose.  It also allows the client to do additional postprocessing of
 the output before building data structures; for example, the client can
 easily discard degeneracies or convert them to another data type.
<br><br>
 The boundaries of polygons and polylines can be modeled as open, semi-open,
 or closed.  Polyline boundaries are controlled by the PolylineModel class,
 whose options are as follows:
<br><br>
  - In the OPEN model, polylines do not contain their first or last vertex.
<br><br>
  - In the SEMI_OPEN model, polylines contain vertices except the last.
    Therefore if one polyline starts where another polyline stops, the two
    polylines do not intersect.
<br><br>
  - In the CLOSED model, polylines contain all of their vertices.
<br><br>
 When multiple polylines are present, they are processed independently and
 have no effect on each other.  For example, in the OPEN boundary model the
 polyline ABC contains the vertex B, while set of polylines {AB, BC} does
 not.  (If you want to treat the polylines as a union instead, with
 boundaries merged according to the "mod 2" rule, this can be achieved by
 reassembling the edges into maximal polylines using S2PolylineVectorLayer
 with EdgeType::UNDIRECTED, DuplicateEdges::MERGE, and PolylineType::WALK.)
<br><br>
 Polygon boundaries are controlled by the PolygonModel class, which has the
 following options:
<br><br>
  - In the OPEN model, polygons do not contain their vertices or edges.
    This implies that a polyline that follows the boundary of a polygon will
    not intersect it.
<br><br>
  - In the SEMI_OPEN model, polygon point containment is defined such that
    if several polygons tile the region around a vertex, then exactly one of
    those polygons contains that vertex.  Similarly polygons contain all of
    their edges, but none of their reversed edges.  This implies that a
    polyline and polygon edge with the same endpoints intersect if and only
    if they are in the same direction.  (This rule ensures that if a
    polyline is intersected with a polygon and its complement, the two
    resulting polylines do not have any edges in common.)
<br><br>
  - In the CLOSED model, polygons contain all their vertices, edges, and
    reversed edges.  This implies that a polyline that shares an edge (in
    either direction) with a polygon is defined to intersect it.  Similarly,
    this is the only model where polygons that touch at a vertex or along an
    edge intersect.
<br><br>
 Note that PolylineModel and PolygonModel are defined as separate classes in
 order to allow for possible future extensions.
<br><br>
 Operations between geometry of different dimensions are defined as follows:
<br><br>
  - For UNION, the higher-dimensional shape always wins.  For example the
    union of a closed polygon A with a polyline B that coincides with the
    boundary of A consists only of the polygon A.
<br><br>
  - For INTERSECTION, the lower-dimensional shape always wins.  For example,
    the intersection of a closed polygon A with a point B that coincides
    with a vertex of A consists only of the point B.
<br><br>
  - For DIFFERENCE, higher-dimensional shapes are not affected by
    subtracting lower-dimensional shapes.  For example, subtracting a point
    or polyline from a polygon A yields the original polygon A.  This rule
    exists because in general, it is impossible to represent the output
    using the specified boundary model(s).  (Consider subtracting one vertex
    from a PolylineModel::CLOSED polyline, or subtracting one edge from a
    PolygonModel::CLOSED polygon.)  If you want to perform operations like
    this, consider representing all boundaries explicitly (topological
    boundaries) using OPEN boundary models.  Another option for polygons is
    to subtract a degenerate loop, which yields a polygon with a degenerate
    hole (see S2LaxPolygonShape).
<br><br>
 Note that in the case of Precision::EXACT operations, the above remarks
 only apply to the output before snapping.  Snapping may cause nearby
 distinct edges to become coincident, e.g. a polyline may become coincident
 with a polygon boundary.  However also note that <code class="code">S2BooleanOperation</code> is
 perfectly happy to accept such geometry as input.
<br><br>
 Note the following differences between <code class="code">S2BooleanOperation</code> and the similar
 S2MultiBooleanOperation class:
<br><br>
  - <code class="code">S2BooleanOperation</code> operates on exactly two regions at a time, whereas
    S2MultiBooleanOperation operates on any number of regions.
<br><br>
  - <code class="code">S2BooleanOperation</code> is potentially much faster when the input is already
    represented as S2ShapeIndexes.  The algorithm is output sensitive and is
    often sublinear in the input size.  This can be a big advantage if, say,
<br><br>
  - <code class="code">S2BooleanOperation</code> supports exact predicates and the corresponding
    exact operations (i.e., operations that are equivalent to computing the
    exact result and then snap rounding it).
<br><br>
  - S2MultiBooleanOperation has better error guarantees when there are many
    regions, since it requires only one snapping operation for any number of
    input regions.
<br><br>
 Example usage:
   S2ShapeIndex a, b;  // Input geometry, e.g. containing polygons.
   S2Polygon polygon;  // Output geometry.
   <code class="code">S2BooleanOperation</code>::Options options;
   options.set_snap_function(snap_function);
   <code class="code">S2BooleanOperation</code> op(<code class="code">S2BooleanOperation</code>::OpType::INTERSECTION,
                         absl::make_unique<S2PolygonLayer>(&polygon),
                         options);
   S2Error error;
   if (!op.Build(a, b, &error)) {
     LOG(ERROR) &lt;&lt; error;
     ...
   }
<br><br>
 If the output includes objects of different dimensions, they can be
 assembled into different layers with code like this:
<br><br>
   vector<S2Point> points;
   vector<unique_ptr<S2Polyline>&gt; polylines;
   S2Polygon polygon;
   <code class="code">S2BooleanOperation</code> op(
       <code class="code">S2BooleanOperation</code>::OpType::UNION,
       absl::make_unique<s2builderutil::PointVectorLayer>(&points),
       absl::make_unique<s2builderutil::S2PolylineVectorLayer>(&polylines),
       absl::make_unique<S2PolygonLayer>(&polygon));
  </p>
</div>

</section>
<ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2BooleanOperation.OpType" id="S2BooleanOperation.OpType"><code class="code">OpType</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2BooleanOperation.OpType"></span>enum <code class="code">OpType</code>: int;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    The supported operation types.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2BooleanOperation.PolygonModel" id="S2BooleanOperation.PolygonModel"><code class="code">PolygonModel</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2BooleanOperation.PolygonModel"></span>enum <code class="code">PolygonModel</code>: int;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Translates OpType to one of the strings above.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    Defines whether polygons are considered to contain their vertices and/or
edges (see definitions above).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2BooleanOperation.PolylineModel" id="S2BooleanOperation.PolylineModel"><code class="code">PolylineModel</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2BooleanOperation.PolylineModel"></span>enum <code class="code">PolylineModel</code>: int;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Defines whether polylines are considered to contain their endpoints
(see definitions above).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2BooleanOperation.Precision" id="S2BooleanOperation.Precision"><code class="code">Precision</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2BooleanOperation.Precision"></span>enum <code class="code">Precision</code>: int;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    With <code class="code">Precision</code>::EXACT, the operation is evaluated using the exact input
 geometry.  Predicates that use this option will produce exact results;
 for example, they can distinguish between a polyline that barely
 intersects a polygon from one that barely misses it.  Constructive
 operations (ones that yield new geometry, as opposed to predicates) are
 implemented by computing the exact result and then snap rounding it
 according to the given snap_function() (see below).  This is as close as
 it is possible to get to the exact result while requiring that vertex
 coordinates have type "double".

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    With <code class="code">Precision</code>::SNAPPED, the input regions are snapped together *before*
 the operation is evaluated.  So for example, two polygons that overlap
 slightly will be treated as though they share a common boundary, and
 similarly two polygons that are slightly separated from each other will
 be treated as though they share a common boundary.  Snapped results are
 useful for dealing with points, since in S2 the only points that lie
 exactly on a polyline or polygon edge are the endpoints of that edge.
<br><br>
 Conceptually, the difference between these two options is that with
 <code class="code">Precision</code>::SNAPPED, the inputs are snap rounded (together), whereas with
 <code class="code">Precision</code>::EXACT only the result is snap rounded.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2BooleanOperation.SourceId" id="S2BooleanOperation.SourceId"><code class="code">SourceId</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2BooleanOperation.SourceId"></span>struct <code class="code">SourceId</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    <code class="code">SourceId</code> identifies an edge from one of the two input S2ShapeIndexes.
 It consists of a region id (0 or 1), a shape id within that region's
 S2ShapeIndex, and an edge id within that shape.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2BooleanOperation.this" id="S2BooleanOperation.this"><code class="code">this</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2BooleanOperation.this"></span>this(OpType <code class="code">op_type</code>, Layer[] <code class="code">layers</code>, Options <code class="code">options</code> = null);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Specifies that the output boundary edges should be sent to three
 different <code class="code">layers</code> according to their dimension.  Points (represented by
 degenerate edges) are sent to layer 0, polyline edges are sent to
 layer 1, and polygon edges are sent to layer 2.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    The dimension of an edge is defined as the minimum dimension of the two
 input edges that produced it.  For example, the intersection of two
 crossing polyline edges is a considered to be a degenerate polyline
 rather than a point, so it is sent to layer 1.  Clients can easily
 reclassify such polylines as points if desired, but this rule makes it
 easier for clients that want to process point, polyline, and polygon
 inputs differently.
<br><br>
 The <code class="code">layers</code> are always built in the order 0, 1, 2, and all arguments to
 the Build() calls are guaranteed to be valid until the last call returns.
 All Graph objects have the same set of vertices and the same lexicon
 objects, in order to make it easier to write classes that process all the
 edges in parallel.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2BooleanOperation.build" id="S2BooleanOperation.build"><code class="code">build</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2BooleanOperation.build"></span>bool <code class="code">build</code>(S2ShapeIndex <code class="code">a</code>, S2ShapeIndex <code class="code">b</code>, ref S2Error <code class="code">error</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Executes the given operation.  Returns <code class="code">true</code> on success, and otherwise
 sets "<code class="code">error</code>" appropriately.  (This class does not generate any errors
 itself, but the S2Builder::Layer might.)
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2BooleanOperation.isEmpty" id="S2BooleanOperation.isEmpty"><code class="code">isEmpty</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2BooleanOperation.isEmpty"></span>static bool <code class="code">isEmpty</code>(OpType <code class="code">op_type</code>, S2ShapeIndex <code class="code">a</code>, S2ShapeIndex <code class="code">b</code>, Options <code class="code">options</code> = null);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Convenience method that returns <code class="code">true</code> if the result of the given operation is empty.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2BooleanOperation.intersects" id="S2BooleanOperation.intersects"><code class="code">intersects</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2BooleanOperation.intersects"></span>static bool <code class="code">intersects</code>(S2ShapeIndex <code class="code">a</code>, S2ShapeIndex <code class="code">b</code>, Options <code class="code">options</code> = null);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Convenience method that returns <code class="code">true</code> if A <code class="code">intersects</code> B.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2BooleanOperation.contains" id="S2BooleanOperation.contains"><code class="code">contains</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2BooleanOperation.contains"></span>static bool <code class="code">contains</code>(S2ShapeIndex <code class="code">a</code>, S2ShapeIndex <code class="code">b</code>, Options <code class="code">options</code> = null);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Convenience method that returns <code class="code">true</code> if A <code class="code">contains</code> B, i.e., if the
difference (B - A) is empty.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#S2BooleanOperation.equals" id="S2BooleanOperation.equals"><code class="code">equals</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="S2BooleanOperation.equals"></span>static bool <code class="code">equals</code>(S2ShapeIndex <code class="code">a</code>, S2ShapeIndex <code class="code">b</code>, Options <code class="code">options</code> = null);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Convenience method that returns <code class="code">true</code> if the symmetric difference of A and
 B is empty.  (Note that A and B may still not be identical, e.g. A may
 contain two copies of <code class="code">a</code> polyline while B contains one.)
  </p>
</div>

</section>

</div>

</li>
</ul>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#CrossingInputEdge" id="CrossingInputEdge"><code class="code">CrossingInputEdge</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="CrossingInputEdge"></span>struct <code class="code">CrossingInputEdge</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    <code class="code">CrossingInputEdge</code> represents an input edge B that crosses some other input
 edge A.  It stores the input edge id of edge B and also whether it crosses
 edge A from left to right (or vice versa).
  </p>
</div>

</section>
<ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#CrossingInputEdge.this" id="CrossingInputEdge.this"><code class="code">this</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="CrossingInputEdge.this"></span>this(InputEdgeId <code class="code">input_id</code>, bool <code class="code">left_to_right</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Indicates that input edge "<code class="code">input_id</code>" crosses another edge (from left to
right if "<code class="code">left_to_right</code>" is <code class="code">true</code>).
  </p>
</div>

</section>

</div>

</li>
</ul>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#InputEdgeCrossings" id="InputEdgeCrossings"><code class="code">InputEdgeCrossings</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="InputEdgeCrossings"></span>alias <code class="code">InputEdgeCrossings</code> = Tuple!(int, CrossingInputEdge)[];

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    <code class="code">InputEdgeCrossings</code> represents all pairs of intersecting input edges.
It is sorted in lexicographic order.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#CrossingGraphEdge" id="CrossingGraphEdge"><code class="code">CrossingGraphEdge</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="CrossingGraphEdge"></span>struct <code class="code">CrossingGraphEdge</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Given two input edges A and B that intersect, suppose that A maps to a
 chain of snapped edges A_0, A_1, ..., A_m and B maps to a chain of snapped
 edges B_0, B_1, ..., B_n.  <code class="code">CrossingGraphEdge</code> represents an edge from chain
 B that shares a vertex with chain A.  It is used as a temporary data
 representation while processing chain A.  The arguments are:

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    "id" - the Graph::EdgeId of an edge from chain B.
   "a_index" - the index of the vertex (A_i) that is shared with chain A.
   "outgoing" - <code class="code">true</code> if the shared vertex is the first vertex of the B edge.
   "dst" - the Graph::VertexId of the vertex that is not shared with chain A.
<br><br>
 Note that if an edge from the B chain shares both vertices with the A
 chain, there will be two entries: an outgoing edge that treats its first
 vertex as being shared, and an incoming edge that treats its second vertex
 as being shared.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#GraphEdgeClipper" id="GraphEdgeClipper"><code class="code">GraphEdgeClipper</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="GraphEdgeClipper"></span>class <code class="code">GraphEdgeClipper</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Given a set of clipping instructions encoded as a set of InputEdgeCrossings,
 <code class="code">GraphEdgeClipper</code> determines which graph edges correspond to clipped
 portions of input edges and removes them.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    The clipping model is as follows.  The input consists of edge chains.  The
 clipper maintains an "inside" boolean state as it clips each chain, and
 toggles this state whenever an input edge is crossed.  Any edges that are
 deemed to be "outside" after clipping are removed.
<br><br>
 The "inside" state can be reset when necessary (e.g., when jumping to the
 start of a new chain) by adding a special crossing marked kSetInside.
 There are also two other special "crossings" that modify the clipping
 parameters: kSetInvertB specifies that edges should be clipped to the
 exterior of the other region, and kSetReverseA specifies that edges should
 be reversed before emitting them (which is needed to implement difference
 operations).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#EdgeClippingLayer" id="EdgeClippingLayer"><code class="code">EdgeClippingLayer</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="EdgeClippingLayer"></span>class <code class="code">EdgeClippingLayer</code>: <span class="ddoc_psuper_symbol">s2.builder.layer.Layer</span>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Given a set of clipping instructions encoded as a set of intersections
 between input edges, <code class="code">EdgeClippingLayer</code> determines which graph edges
 correspond to clipped portions of input edges and removes them.  It
 assembles the remaining edges into a new S2Builder::Graph and passes the
 result to the given output layer for assembly.
  </p>
</div>

</section>
<ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#EdgeClippingLayer.graphOptions" id="EdgeClippingLayer.graphOptions"><code class="code">graphOptions</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="EdgeClippingLayer.graphOptions"></span>const GraphOptions <code class="code">graphOptions</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Layer interface:
  </p>
</div>

</section>

</div>

</li>
</ul>

</div>

</li>
</ul>
  </div>
</section>
</section>
      </article>
    </div>
  </body>
</html>
